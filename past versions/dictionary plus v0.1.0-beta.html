<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vocabulary Management System</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üìö</text></svg>">
    <style>
	    /* Êñ∞Â¢ûËÉåÊôØÈÄâÈ°πÊ†∑Âºè */
    .background-options {
        margin: 15px 0;
    }
    .background-option {
        display: inline-block;
        width: 60px;
        height: 60px;
        margin: 5px;
        border: 2px solid #444;
        border-radius: 5px;
        cursor: pointer;
    }
    .background-option:hover {
        border-color: #0077ff;
    }
    .background-option.selected {
        border-color: #00ff00;
    }
    #customBgUpload {
        display: none;
    }
    .custom-bg-label {
        display: inline-block;
        padding: 8px 15px;
        background-color: #0077ff;
        color: white;
        border-radius: 3px;
        cursor: pointer;
        margin: 10px 0;
    }
    .custom-bg-label:hover {
        background-color: #0099ff;
    }
        body {
            font-family: 'Courier New', monospace;
            background-color: #1a1a1a;
            color: #e0e0e0;
            margin: 0;
            padding: 20px;
            line-height: 1.6;
        }
        #app {
            max-width: 800px;
            margin: 0 auto;
            background-color: #2a2a2a;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        .title {
            color: #00ffff;
            text-align: center;
            margin-bottom: 20px;
            font-weight: bold;
        }
        .separator {
            border-top: 1px solid #0077ff;
            margin: 15px 0;
        }
        .menu-item {
            margin: 10px 0;
            cursor: pointer;
            padding: 5px;
        }
        .menu-item:hover {
            background-color: #333;
        }
        .selected {
            color: #00ff00;
            font-weight: bold;
            background-color: #333;
        }
        .input-container {
            background-color: #333;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
        }
        input {
            background-color: #444;
            color: #fff;
            border: 1px solid #555;
            padding: 8px;
            width: calc(100% - 20px);
            margin-bottom: 10px;
            font-family: inherit;
            border-radius: 3px;
        }
        textarea {
            background-color: #444;
            color: #fff;
            border: 1px solid #555;
            padding: 8px;
            width: calc(100% - 20px);
            margin-bottom: 10px;
            font-family: inherit;
            border-radius: 3px;
            min-height: 100px;
            resize: vertical;
            white-space: pre-wrap;
        }
        .button-group {
            margin-top: 10px;
        }
        button {
            background-color: #0077ff;
            color: white;
            border: none;
            padding: 8px 15px;
            margin-right: 5px;
            cursor: pointer;
            border-radius: 3px;
            font-family: inherit;
        }
        button:hover {
            background-color: #0099ff;
        }
        button.cancel {
            background-color: #666;
        }
        button.cancel:hover {
            background-color: #777;
        }
        .word-group {
            margin: 10px 0;
            padding: 10px;
            background-color: #333;
            border-radius: 5px;
        }
        .word-item {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            background-color: #444;
            border-radius: 3px;
        }
        .correct {
            color: #00ff00;
        }
        .incorrect {
            color: #ff0000;
        }
        .status-bar {
            margin-top: 15px;
            padding: 8px;
            background-color: #333;
            font-size: 0.9em;
            border-radius: 3px;
        }
        .quiz-question {
            margin-bottom: 15px;
            padding: 10px;
            background-color: #333;
            border-radius: 5px;
        }
        .confirm-prompt {
            margin: 10px 0;
            padding: 10px;
            background-color: #444;
            border-radius: 5px;
        }
        .quiz-prompt {
            margin: 10px 0;
            font-weight: bold;
        }
        .file-input-container {
            margin: 15px 0;
        }
        .file-input-label {
            display: block;
            margin-bottom: 10px;
        }
        .import-preview {
            max-height: 200px;
            overflow-y: auto;
            background-color: #333;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
        }
        .import-preview-item {
            margin: 5px 0;
            padding: 5px;
            border-bottom: 1px solid #444;
        }
        .recycle-bin-item {
            margin: 5px 0;
            padding: 8px;
            background-color: #444;
            border-radius: 3px;
            display: flex;
            justify-content: space-between;
        }
        .recycle-bin-actions {
            display: flex;
            gap: 5px;
        }
        .bulletin-board {
            margin: 15px 0;
        }
        .bulletin-item {
            background-color: #333;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 5px;
            border-left: 3px solid #0077ff;
            white-space: pre-wrap;
        }
        .bulletin-title {
            font-weight: bold;
            margin-bottom: 5px;
            color: #00ffff;
        }
        .bulletin-content {
            margin-bottom: 5px;
        }
        .bulletin-meta {
            font-size: 0.8em;
            color: #999;
            text-align: right;
        }
        .admin-controls {
            margin-top: 10px;
            display: flex;
            justify-content: flex-end;
            gap: 5px;
        }
        .vocab-word {
            margin: 5px 0;
            padding: 8px;
            background-color: #444;
            border-radius: 3px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .word-status {
            display: flex;
            gap: 5px;
        }
        .status-btn {
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
        }
        .status-known {
            background-color: #00aa00;
        }
        .status-unknown {
            background-color: #aa0000;
        }
        .status-unsure {
            background-color: #aa5500;
        }
        .word-stats {
            margin-top: 10px;
            padding: 10px;
            background-color: #333;
            border-radius: 5px;
        }
        .analyze-progress {
            margin-top: 10px;
            height: 5px;
            background-color: #444;
            border-radius: 3px;
            overflow: hidden;
        }
        .progress-bar {
            height: 100%;
            background-color: #0077ff;
            width: 0%;
            transition: width 0.3s;
        }
        .word-list {
            max-height: 400px;
            overflow-y: auto;
            margin: 15px 0;
        }
        .export-options {
            margin: 15px 0;
        }
        .export-option {
            margin: 10px 0;
            padding: 10px;
            background-color: #333;
            border-radius: 5px;
            cursor: pointer;
        }
        .export-option:hover {
            background-color: #444;
        }
        .export-option.selected {
            background-color: #0077ff;
        }
        .recycle-bin-source {
            font-size: 0.8em;
            color: #aaa;
            margin-top: 3px;
        }
	        /* Êñ∞Â¢ûÊó•ÂéÜÂíåÁªüËÆ°ÂõæË°®Ê†∑Âºè */
        .calendar-container {
            margin: 15px 0;
            padding: 15px;
            background-color: #333;
            border-radius: 5px;
        }
        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .calendar-nav {
            display: flex;
            gap: 10px;
        }
        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 5px;
        }
        .calendar-day {
            padding: 8px;
            text-align: center;
            background-color: #444;
            border-radius: 3px;
            cursor: pointer;
        }
        .calendar-day.empty {
            background-color: transparent;
            cursor: default;
        }
        .calendar-day.today {
            border: 2px solid #00ffff;
        }
        .calendar-day.has-data {
            background-color: #0077ff;
        }
        .calendar-day.efficient {
            background-color: #00aa00;
        }
        .calendar-day.inefficient {
            background-color: #aa0000;
        }
        .stats-container {
            margin-top: 20px;
        }
        .stats-chart {
            height: 200px;
            margin-top: 15px;
            display: flex;
            align-items: flex-end;
            justify-content: space-around;
        }
        .chart-bar {
            width: 30px;
            background-color: #0077ff;
            position: relative;
            text-align: center;
        }
        .chart-bar.efficient {
            background-color: #00aa00;
        }
        .chart-bar.inefficient {
            background-color: #aa0000;
        }
        .chart-label {
            position: absolute;
            bottom: -25px;
            width: 100%;
            font-size: 0.8em;
        }
        .chart-value {
            position: absolute;
            top: -25px;
            width: 100%;
            font-size: 0.8em;
        }
        .day-details {
            margin-top: 15px;
            padding: 10px;
            background-color: #444;
            border-radius: 5px;
        }
	/* Âú®Áé∞ÊúâÁöÑÊó•ÂéÜÊ†∑ÂºèÂêéÈù¢Ê∑ªÂä† */
	.calendar-day.no-data {
 	   background-color: #aa0000;
	    opacity: 0.5;
	}

	.calendar-day > div {
   	 margin: 2px 0;
	}
    	.bulletin-title::after {
  	      content: " ‚ñº";
   	      font-size: 0.8em;
 	      opacity: 0.7;
  	}
  	.bulletin-title.collapsed::after {
  	     content: " ‚ñ∂";
 	}
    </style>
</head>
<body>
    <div id="app">
        <div class="title">Vocabulary Management System v0.1.0 ( beta )</div>
        <div class="separator"></div>
        
        <div id="menu">
            <div class="menu-item" data-choice="1">1. Add new words</div>
            <div class="menu-item" data-choice="2">2. Show word groups/synonyms</div>
            <div class="menu-item" data-choice="3">3. Vocabulary quiz</div>
            <div class="menu-item" data-choice="4">4. Delete single word</div>
            <div class="menu-item" data-choice="5">5. Exit program</div>
            <div class="menu-item" data-choice="6">6. List all words</div>
            <div class="menu-item" data-choice="7">7. Clear all words</div>
            <div class="menu-item" data-choice="8">8. Delete entire word group</div>
            <div class="menu-item" data-choice="9">9. Import TXT file</div>
            <div class="menu-item" data-choice="10">10. Export TXT file</div>
            <div class="menu-item" data-choice="11">11. Recycle Bin</div>
            <div class="menu-item" data-choice="12">12. Bulletin Board</div>
            <div class="menu-item" data-choice="13">13. Analyze text for vocabulary</div>
            <div class="menu-item" data-choice="14">14. View known words</div>
            <div class="menu-item" data-choice="15">15. View unknown words</div>
            <div class="menu-item" data-choice="16">16. View unsure words</div>
	    <div class="menu-item" data-choice="17">17. Vocabulary Review</div>
	    <div class="menu-item" data-choice="18">18. Customize app</div>
            <div class="menu-item" data-choice="19">19. Learning Calendar</div>
        </div>
        
        <div id="content"></div>
        
        <div class="separator"></div>
        <div id="status" class="status-bar">Ready</div>
    </div>

    <script>
        // Constants
        const N = 10000;
        const DATA_KEY = "vocabulary_data";
        const RECYCLE_BIN_KEY = "recycle_bin_data";
        const BULLETIN_BOARD_KEY = "bulletin_board_data";
        const VOCAB_STATS_KEY = "vocabulary_stats";
        // Update the ADMIN_PASSWORD constant to be an object with username and password
const ADMIN_PASSWORD = {
    username: "Nick_zheng",
    password: "nick20090120" // Simple password for demo purposes
};
        
        // Data structures
        let fa = Array(N).fill(0).map((_, i) => i);
        let mp = new Map();
        let vis = Array(N).fill(false);
        let bac = Array(N).fill("");
        let cnt = 0;
        let recycleBin = [];
        let bulletinBoard = [];
        let vocabStats = {};
        let isAdmin = false;
        
        // DOM elements
        const app = document.getElementById('app');
        const menu = document.getElementById('menu');
        const content = document.getElementById('content');
        const statusBar = document.getElementById('status');
        
        // Current state
        let currentChoice = null;
        let currentQuestion = null;
        let quizScore = 0;
        let quizTotal = 0;
        let currentRootWord = "";
        
        // Initialize
        init();
        
        function init() {
    // ÂàùÂßãÂåñ‰∫ã‰ª∂ÁõëÂê¨Âô®
    menu.querySelectorAll('.menu-item').forEach(item => {
        item.addEventListener('click', () => handleMenuChoice(item.dataset.choice));
    });
    
    // Âä†ËΩΩËÉåÊôØËÆæÁΩÆ
    const savedColor = localStorage.getItem('vocab_bg_color');
    const savedImage = localStorage.getItem('vocab_bg_image');
    const savedOpacity = localStorage.getItem('vocab_bg_opacity');
    const savedIcon = localStorage.getItem('vocab_custom_icon');
    
    if (savedColor) {
        document.body.style.background = savedColor;
    } else if (savedImage) {
        document.body.style.backgroundImage = `url(${savedImage})`;
        document.body.style.backgroundSize = 'cover';
        document.body.style.backgroundAttachment = 'fixed';
    }
    
    if (savedOpacity) {
        document.body.style.opacity = `${savedOpacity / 100}`;
    }
    
    if (savedIcon) {
        const link = document.querySelector("link[rel~='icon']") || document.createElement("link");
        link.rel = "icon";
        link.href = savedIcon;
        document.head.appendChild(link);
    }
    
    // Âä†ËΩΩÊï∞ÊçÆ
    loadData();
    updateStatus("System ready");
}
        
        // Core functions
        function find(x) {
            return fa[x] = (fa[x] === x ? x : find(fa[x]));
        }
        
        function union_set(x, y) {
            fa[find(x)] = find(y);
        }
        
        function clearContent() {
            content.innerHTML = '';
        }
        
        function updateStatus(message) {
            statusBar.textContent = message;
        }
        
        // Data storage functions
        function loadData() {
            // Load main vocabulary data
            const savedData = localStorage.getItem(DATA_KEY);
            if (savedData) {
                try {
                    const data = JSON.parse(savedData);
                    mp = new Map(data.mp);
                    fa = data.fa;
                    bac = data.bac;
                    cnt = data.cnt;
                    
                    updateStatus("Vocabulary data loaded");
                } catch (e) {
                    updateStatus("Error loading data, using empty dictionary");
                    console.error(e);
                }
            } else {
                updateStatus("No vocabulary data found, using empty dictionary");
            }
            
            // Load recycle bin data
            const savedRecycleBin = localStorage.getItem(RECYCLE_BIN_KEY);
            if (savedRecycleBin) {
                try {
                    recycleBin = JSON.parse(savedRecycleBin);
                updateStatus("Recycle bin data loaded");
                } catch (e) {
                    console.error("Error loading recycle bin:", e);
                    recycleBin = [];
                }
            }
            
            // Load bulletin board data
            const savedBulletinBoard = localStorage.getItem(BULLETIN_BOARD_KEY);
            if (savedBulletinBoard) {
                try {
                    bulletinBoard = JSON.parse(savedBulletinBoard);
                    updateStatus("Bulletin board data loaded");
                } catch (e) {
                    console.error("Error loading bulletin board:", e);
                    bulletinBoard = [];
                }
            }
            
            // Load vocabulary stats
            const savedVocabStats = localStorage.getItem(VOCAB_STATS_KEY);
            if (savedVocabStats) {
                try {
                    vocabStats = JSON.parse(savedVocabStats);
                    updateStatus("Vocabulary stats loaded");
                } catch (e) {
                    console.error("Error loading vocabulary stats:", e);
                    vocabStats = {};
                }
            }
        }
        
	function cleanupEmptyGroups() {
    const groupRoots = new Set();
    const groups = new Map();
    
    // Êî∂ÈõÜÊâÄÊúâÁªÑÁöÑÊ†πËäÇÁÇπ
    for (const [word, id] of mp) {
        const root = find(id);
        groupRoots.add(root);
        
        if (!groups.has(root)) {
            groups.set(root, []);
        }
        groups.get(root).push(word);
    }
    
    // Ê£ÄÊü•ÊØè‰∏™ÁªÑÊòØÂê¶ÊúâÊàêÂëò
    for (const root of groupRoots) {
        const groupWords = groups.get(root);
        if (groupWords.length === 0) {
            // ËøôÊòØ‰∏Ä‰∏™Á©∫ÁªÑÔºåÈúÄË¶ÅÊ∏ÖÁêÜ
            for (let i = 1; i <= cnt; i++) {
                if (find(i) === root) {
                    fa[i] = i;  // ÈáçÁΩÆÁà∂ËäÇÁÇπ
                    bac[i] = ""; // Ê∏ÖÁ©∫ÂèçÂêëÊò†Â∞Ñ
                }
            }
        }
    }
    
    // ÈáçÊñ∞ËÆ°Êï∞
    cnt = 0;
    const newMp = new Map();
    for (const [word, id] of mp) {
        if (bac[id] !== "") {  // Âè™‰øùÁïôÊúâÊïàÁöÑÊò†Â∞Ñ
            newMp.set(word, id);
            cnt = Math.max(cnt, id);
        }
    }
    mp = newMp;
}

        function saveData() {

	cleanupEmptyGroups();

            const data = {
                mp: Array.from(mp.entries()),
                fa: fa,
                bac: bac,
                cnt: cnt
            };
            
            try {
                localStorage.setItem(DATA_KEY, JSON.stringify(data));
                localStorage.setItem(RECYCLE_BIN_KEY, JSON.stringify(recycleBin));
                localStorage.setItem(BULLETIN_BOARD_KEY, JSON.stringify(bulletinBoard));
                localStorage.setItem(VOCAB_STATS_KEY, JSON.stringify(vocabStats));
                updateStatus("Data saved");
                return true;
            } catch (e) {
                updateStatus("Error saving data");
                console.error(e);
                return false;
            }
        }
        
        // Menu handler
        function handleMenuChoice(choice) {
            currentChoice = choice;
            
            // Clear previous selection
            menu.querySelectorAll('.menu-item').forEach(item => {
                item.classList.remove('selected');
            });
            
            // Highlight current selection
            document.querySelector(`.menu-item[data-choice="${choice}"]`).classList.add('selected');
            
            clearContent();
            
            switch (choice) {
                case '1':
                    showAddWords();
                    break;
                case '2':
                    showFindGroup();
                    break;
                case '3':
                    startQuiz();
                    break;
                case '4':
                    showRemoveWord();
                    break;
                case '5':
                    exitProgram();
                    break;
                case '6':
                    showAllWords();
                    break;
                case '7':
                    showClearAll();
                    break;
                case '8':
                    showRemoveGroup();
                    break;
                case '9':
                    showImportTxt();
                    break;
                case '10':
                    showExportTxt();
                    break;
                case '11':
                    showRecycleBin();
                    break;
                case '12':
                    showBulletinBoard();
                    break;
                case '13':
                    showTextAnalyzer();
                    break;
                case '14':
                    showWordList('known');
                    break;
                case '15':
                    showWordList('unknown');
                    break;
                case '16':
                    showWordList('unsure');
                    break;
		case '17':
    			showReviewSetup();
   			 break;
		case '18':
                    showBackgroundCustomizer();
                    break;
                case '19':
                    showLearningCalendar();
                    break;
                default:
                    updateStatus("Invalid choice");
            }
        }
        
        // Input handling
        function showInput(promptText, onSubmit, onCancel) {
            clearContent();
            
            const container = document.createElement('div');
            container.className = 'input-container';
            
            const prompt = document.createElement('p');
            prompt.textContent = promptText;
            container.appendChild(prompt);
            
            const input = document.createElement('input');
            input.type = 'text';
            input.placeholder = 'Enter text...';
            input.autocomplete = 'off';
            container.appendChild(input);
            
            const buttonGroup = document.createElement('div');
            buttonGroup.className = 'button-group';
            
            const submitButton = document.createElement('button');
            submitButton.textContent = 'Submit';
            submitButton.addEventListener('click', () => {
                const value = input.value.trim();
                if (value) {
                    onSubmit(value);
                }
            });
            
            const cancelButton = document.createElement('button');
            cancelButton.textContent = 'Cancel';
            cancelButton.className = 'cancel';
            cancelButton.addEventListener('click', () => {
                if (onCancel) onCancel();
                clearContent();
                updateStatus("Operation canceled");
            });
            
            buttonGroup.appendChild(submitButton);
            buttonGroup.appendChild(cancelButton);
            container.appendChild(buttonGroup);
            
            content.appendChild(container);
            input.focus();
            
            // Add keyboard event
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    const value = input.value.trim();
                    if (value) {
                        onSubmit(value);
                    }
                }
            });
        }
        
        function showTextArea(promptText, onSubmit, onCancel) {
            clearContent();
            
            const container = document.createElement('div');
            container.className = 'input-container';
            
            const prompt = document.createElement('p');
            prompt.textContent = promptText;
            container.appendChild(prompt);
            
            const textarea = document.createElement('textarea');
            textarea.placeholder = 'Enter text...';
            container.appendChild(textarea);
            
            const buttonGroup = document.createElement('div');
            buttonGroup.className = 'button-group';
            
            const submitButton = document.createElement('button');
            submitButton.textContent = 'Submit';
            submitButton.addEventListener('click', () => {
                const value = textarea.value.trim();
                if (value) {
                    onSubmit(value);
                }
            });
            
            const cancelButton = document.createElement('button');
            cancelButton.textContent = 'Cancel';
            cancelButton.className = 'cancel';
            cancelButton.addEventListener('click', () => {
                if (onCancel) onCancel();
                clearContent();
                updateStatus("Operation canceled");
            });
            
            buttonGroup.appendChild(submitButton);
            buttonGroup.appendChild(cancelButton);
            container.appendChild(buttonGroup);
            
            content.appendChild(container);
            textarea.focus();
        }
        
        // Feature implementations
        function showAddWords() {
            showInput("Enter root word:", (rootWord) => {
                if (!mp.has(rootWord)) {
                    mp.set(rootWord, ++cnt);
                    bac[cnt] = rootWord;
                }
                
                currentRootWord = rootWord;
                addRelatedWords();
            });
        }
        
        function addRelatedWords() {
            showInput("Enter related words (space separated):", (relatedWords) => {
                const words = relatedWords.split(/\s+/).filter(w => w);
                
                for (let word of words) {
                    if (!mp.has(word)) {
                        mp.set(word, ++cnt);
                        bac[cnt] = word;
                    }
                    
                    union_set(mp.get(currentRootWord), mp.get(word));
                }
                
                // Show added words
                if (words.length > 0) {
                    const feedback = document.createElement('p');
                    feedback.textContent = `Added related words: ${words.join(', ')}`;
                    content.appendChild(feedback);
                }
                
                // Save data and show success message
                if (saveData()) {
                    const successMsg = document.createElement('p');
                    successMsg.className = 'correct';
                    successMsg.textContent = 'Word associations saved successfully!';
                    content.appendChild(successMsg);
                }
            });
        }
        
        function showFindGroup() {
            showInput("Enter a word to find its group:", (word) => {
                if (mp.has(word)) {
                    const root = find(mp.get(word));
                    let group = [];
                    
                    for (const [w, id] of mp) {
                        if (find(id) === root) {
                            group.push(w);
                        }
                    }
                    
                    const resultDiv = document.createElement('div');
                    
                    const title = document.createElement('h3');
                    title.textContent = `Words related to "${word}":`;
                    resultDiv.appendChild(title);
                    
                    const wordGroup = document.createElement('div');
                    wordGroup.className = 'word-group';
                    
                    group.forEach(w => {
                        const wordSpan = document.createElement('span');
                        wordSpan.className = 'word-item';
                        wordSpan.textContent = w;
                        wordGroup.appendChild(wordSpan);
                    });
                    
                    resultDiv.appendChild(wordGroup);
                    clearContent();
                    content.appendChild(resultDiv);
                    
                    updateStatus(`Found ${group.length} related words`);
                } else {
                    clearContent();
                    const errorMsg = document.createElement('p');
                    errorMsg.className = 'incorrect';
                    errorMsg.textContent = 'Word not found in dictionary';
                    content.appendChild(errorMsg);
                    updateStatus("Word not found");
                }
            });
        }
        
        function startQuiz() {
            if (mp.size < 5) {
                const errorMsg = document.createElement('p');
                errorMsg.className = 'incorrect';
                errorMsg.textContent = 'Not enough words in dictionary (minimum 5 required)';
                content.appendChild(errorMsg);
                updateStatus("Not enough words");
                return;
            }
            
            quizScore = 0;
            quizTotal = 0;
            vis.fill(false);
            
            clearContent();
            
            const quizIntro = document.createElement('div');
            quizIntro.innerHTML = `
                <h3>Vocabulary Quiz (5 questions)</h3>
                <p>Enter synonyms for each word:</p>
                <p><span class="correct">Correct: +1 point</span>, <span class="incorrect">Wrong: -1 point</span></p>
                <div class="separator"></div>
            `;
            content.appendChild(quizIntro);
            
            askQuizQuestion(1);
        }
        
        function askQuizQuestion(questionNum) {
            if (questionNum > 5) {
                // Quiz finished
                const resultDiv = document.createElement('div');
                resultDiv.innerHTML = `
                    <div class="separator"></div>
                    <h3 class="${quizScore > 0 ? 'correct' : (quizScore < 0 ? 'incorrect' : '')}">
                        Quiz completed. Total score: ${quizScore} points
                    </h3>
                `;
                content.appendChild(resultDiv);
                updateStatus("Quiz completed");
                return;
            }
            
            const size = mp.size;
            let rd = Math.floor(Math.random() * size) + 1;
            while (vis[rd]) {
                rd = Math.floor(Math.random() * size) + 1;
            }
            vis[rd] = true;
            
            currentQuestion = {
                number: questionNum,
                word: bac[rd],
                root: find(rd),
                score: 0
            };
            
            const questionDiv = document.createElement('div');
            questionDiv.className = 'quiz-question';
            questionDiv.innerHTML = `<h4>Question ${questionNum}: ${currentQuestion.word}</h4>`;
            content.appendChild(questionDiv);
            
            const promptDiv = document.createElement('div');
            promptDiv.className = 'quiz-prompt';
            promptDiv.textContent = `Enter synonyms for "${currentQuestion.word}":`;
            content.appendChild(promptDiv);
            
            const container = document.createElement('div');
            container.className = 'input-container';
            
            const input = document.createElement('input');
            input.type = 'text';
            input.placeholder = 'Enter synonyms...';
            input.autocomplete = 'off';
            container.appendChild(input);
            
            const buttonGroup = document.createElement('div');
            buttonGroup.className = 'button-group';
            
            const submitButton = document.createElement('button');
            submitButton.textContent = 'Submit';
            submitButton.addEventListener('click', () => {
                const value = input.value.trim();
                if (value) {
                    handleQuizAnswer(value);
                }
            });
            
            const cancelButton = document.createElement('button');
            cancelButton.textContent = 'Cancel Quiz';
            cancelButton.className = 'cancel';
            cancelButton.addEventListener('click', () => {
                clearContent();
                updateStatus("Quiz canceled");
            });
            
            buttonGroup.appendChild(submitButton);
            buttonGroup.appendChild(cancelButton);
            container.appendChild(buttonGroup);
            
            content.appendChild(container);
            input.focus();
            
            // Add keyboard event
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    const value = input.value.trim();
                    if (value) {
                        handleQuizAnswer(value);
                    }
                }
            });
        }
        
        function handleQuizAnswer(answer) {
            const words = answer.split(/\s+/).filter(w => w);
            let questionScore = 0;
            let feedback = "";
            
            for (let ans of words) {
                if (mp.has(ans) && find(mp.get(ans)) === currentQuestion.root) {
                    if (ans !== currentQuestion.word) {
                        questionScore++;
                        feedback += `<span class="correct">‚úì ${ans} correct! </span>`;
                    }
                } else {
                    questionScore--;
                    feedback += `<span class="incorrect">‚úó ${ans} wrong! </span>`;
                }
            }
            
            const scoreClass = questionScore > 0 ? 'correct' : 'incorrect';
            const resultDiv = document.createElement('div');
            resultDiv.innerHTML = `
                ${feedback}
                <p>Question score: <span class="${scoreClass}">${questionScore} points</span></p>
                <div class="separator"></div>
            `;
            content.appendChild(resultDiv);
            
            quizScore += questionScore;
            askQuizQuestion(currentQuestion.number + 1);
        }
        
        // ‰øÆÊîπ showRemoveWord() ÂáΩÊï∞
function showRemoveWord() {
    showInput("Enter word to delete from word groups:", (word) => {
        if (!mp.has(word)) {
            clearContent();
            const errorMsg = document.createElement('p');
            errorMsg.className = 'incorrect';
            errorMsg.textContent = 'Word not found in word groups';
            content.appendChild(errorMsg);
            
            const backButton = document.createElement('button');
            backButton.textContent = 'Back';
            backButton.className = 'cancel';
            backButton.addEventListener('click', () => {
                handleMenuChoice('4');
            });
            content.appendChild(backButton);
            return;
        }

        // Ê†∏ÂøÉ‰øùÊä§ÈÄªËæëÔºöÊ£ÄÊü•ÊòØÂê¶Âú®Áä∂ÊÄÅÂàóË°®
        const status = vocabStats[word];
        const statusNote = status ? 
            `\n\n‚ö†Ô∏è Note: This word is marked as "${status}" in your vocab list. ` +
            `It will ONLY be removed from word groups.` : "";

        showConfirm(`Delete "${word}" from word groups?${statusNote}`, (confirmed) => {
            if (!confirmed) return;
            
            // ‰ªÖÊìç‰Ωúword groupsÁ≥ªÁªü
            const root = find(mp.get(word));
            const deletedWords = [];
            
            // ËÆ∞ÂΩïË¶ÅÂà†Èô§ÁöÑÁªÑ
            for (const [w, id] of mp) {
                if (find(id) === root) {
                    deletedWords.push(w);
                    mp.delete(w); // ‰ªÖÂà†Èô§‰∏ªÂçïËØçÁªÑËÆ∞ÂΩï
                }
            }

            // ‰øùÂ≠òÂà∞ÂõûÊî∂Á´ôÔºàÊ≥®Êòé‰∏çÂΩ±ÂìçÁä∂ÊÄÅÔºâ
            recycleBin.push({
                word: word,
                group: deletedWords,
                timestamp: new Date().toISOString(),
                source: `Deleted from word groups (status kept as ${status || 'none'})`
            });

            saveData();
            
            // ÊòæÁ§∫ÁªìÊûúÔºàÊòéÁ°ÆÊèêÁ§∫Áä∂ÊÄÅ‰øùÁïôÔºâ
            clearContent();
            const result = document.createElement('div');
            result.innerHTML = `
                <p class="correct">"${word}" removed from word groups</p>
                ${status ? `<p>Its "${status}" status was preserved.</p>` : ''}
                <button onclick="handleMenuChoice('${currentChoice}')">Continue</button>
            `;
            content.appendChild(result);
        });
    });
}        
        function getStatusViewName(choice) {
            switch(choice) {
                case '14': return 'known';
                case '15': return 'unknown';
                case '16': return 'unsure';
                default: return '';
            }
        }
        
       function showClearAll() {
    showConfirm("Warning: This will reset all word groups (not vocabulary status)! Confirm?", (confirmed) => {
        if (confirmed) {
            // Save current word groups to recycle bin
            const allWords = Array.from(mp.keys());
            if (allWords.length > 0) {
                recycleBin.push({
                    word: "ALL_WORDS",
                    group: allWords,
                    timestamp: new Date().toISOString(),
                    source: 'Clear all word groups'
                });
            }
            
            // Only clear word groups, not vocab stats
            mp.clear();
            cnt = 0;
            for (let i = 0; i < N; i++) {
                fa[i] = i;
                bac[i] = "";
            }
            
            saveData();
            clearContent();
            const successMsg = document.createElement('p');
            successMsg.className = 'correct';
            successMsg.textContent = 'All word groups cleared (vocabulary status preserved)';
            content.appendChild(successMsg);
        } else {
            clearContent();
            const cancelMsg = document.createElement('p');
            cancelMsg.textContent = 'Operation canceled';
            content.appendChild(cancelMsg);
        }
    });
}
        
        function showRemoveGroup() {
            showInput("Enter any word from the group:", (word) => {
                if (!mp.has(word)) {
                    clearContent();
                    const errorMsg = document.createElement('p');
                    errorMsg.className = 'incorrect';
                    errorMsg.textContent = 'Word not found in dictionary';
                    content.appendChild(errorMsg);
                    return;
                }
                
                const root = find(mp.get(word));
                const groupWords = [];
                
                for (const [w, id] of mp) {
                    if (find(id) === root) {
                        groupWords.push(w);
                    }
                }
                
                clearContent();
                
                const warningDiv = document.createElement('div');
                warningDiv.innerHTML = `
                    <p class="incorrect">The following words will be deleted:</p>
                    <div class="word-group">
                        ${groupWords.map(w => `<span class="word-item">${w}</span>`).join('')}
                    </div>
                `;
                content.appendChild(warningDiv);
                
                showConfirm("Confirm deletion of entire word group?", (confirmed) => {
                    if (confirmed) {
                        // Save to recycle bin before deleting
                        recycleBin.push({
                            word: word,
                            group: groupWords,
                            timestamp: new Date().toISOString(),
                            source: 'Word group deletion'
                        });
                        
                        for (const w of groupWords) {
                            mp.delete(w);
                            // Don't remove from vocab stats - they are separate systems
                        }
                        saveData();
                        clearContent();
                        const successMsg = document.createElement('p');
                        successMsg.className = 'correct';
                        successMsg.textContent = 'Word group deleted successfully';
                        content.appendChild(successMsg);
                    } else {
                        clearContent();
                        const cancelMsg = document.createElement('p');
                        cancelMsg.textContent = 'Deletion canceled';
                        content.appendChild(cancelMsg);
                    }
                });
            });
        }
        
       function showAllWords() {
    const printedGroups = new Set();
    let totalWords = 0;
    
    clearContent();
    
    const title = document.createElement('h3');
    title.textContent = 'Dictionary Contents';
    content.appendChild(title);
    
    // ÂàõÂª∫ÊªöÂä®ÂÆπÂô®
    const scrollContainer = document.createElement('div');
    scrollContainer.className = 'word-list';
    scrollContainer.style.maxHeight = '500px';
    scrollContainer.style.overflowY = 'auto';
    scrollContainer.style.margin = '15px 0';
    
    for (let i = 1; i <= cnt; i++) {
        if (!mp.has(bac[i])) continue;
        
        const root = find(i);
        if (printedGroups.has(root)) continue;
        
        // Ê£ÄÊü•Ëøô‰∏™ÁªÑÊòØÂê¶ÊúâÂçïËØç
        let hasWords = false;
        for (const [w, id] of mp) {
            if (find(id) === root) {
                hasWords = true;
                break;
            }
        }
        
        if (!hasWords) continue;
        
        printedGroups.add(root);
        
        const groupTitle = document.createElement('h4');
        groupTitle.textContent = `Word Group #${printedGroups.size}:`;
        scrollContainer.appendChild(groupTitle);
        
        const wordGroup = document.createElement('div');
        wordGroup.className = 'word-group';
        
        for (const [w, id] of mp) {
            if (find(id) === root) {
                const wordSpan = document.createElement('span');
                wordSpan.className = 'word-item';
                wordSpan.textContent = w;
                wordGroup.appendChild(wordSpan);
                totalWords++;
            }
        }
        
        scrollContainer.appendChild(wordGroup);
    }
    
    content.appendChild(scrollContainer);
    
    const summaryDiv = document.createElement('div');
    summaryDiv.innerHTML = `
        <div class="separator"></div>
        <p>Total: ${totalWords} words, ${printedGroups.size} word groups</p>
    `;
    content.appendChild(summaryDiv);
    
    updateStatus("Displaying all words");
}
        
        function showImportTxt() {
            clearContent();
            
            const container = document.createElement('div');
            container.className = 'input-container';
            
            const title = document.createElement('h3');
            title.textContent = 'Import TXT File';
            container.appendChild(title);
            
            const instructions = document.createElement('p');
            instructions.textContent = 'Select import type:';
            container.appendChild(instructions);
            
            const optionsDiv = document.createElement('div');
            optionsDiv.className = 'export-options';
            
            // Option 1: Import word groups
            const option1 = document.createElement('div');
            option1.className = 'export-option';
            option1.innerHTML = `
                <h4>Word Groups</h4>
                <p>One word group per line, words separated by spaces</p>
            `;
            option1.addEventListener('click', () => {
                showImportWordGroups();
            });
            
            // Option 2: Import vocabulary stats
            const option2 = document.createElement('div');
            option2.className = 'export-option';
            option2.innerHTML = `
                <h4>Vocabulary Stats</h4>
                <p>One word per line with status (format: word:status)</p>
            `;
            option2.addEventListener('click', () => {
                showImportVocabStats();
            });
            
            optionsDiv.appendChild(option1);
            optionsDiv.appendChild(option2);
            container.appendChild(optionsDiv);
            
            const backButton = document.createElement('button');
            backButton.textContent = 'Back';
            backButton.className = 'cancel';
            backButton.addEventListener('click', () => {
                clearContent();
                updateStatus("Import canceled");
            });
            
            container.appendChild(backButton);
            content.appendChild(container);
            updateStatus("Select import type");
        }
        
        function showImportWordGroups() {
            clearContent();
            
            const container = document.createElement('div');
            container.className = 'input-container';
            
            const title = document.createElement('h3');
            title.textContent = 'Import Word Groups';
            container.appendChild(title);
            
            const instructions = document.createElement('p');
            instructions.textContent = 'Select a TXT file (one word group per line, words separated by spaces):';
            container.appendChild(instructions);
            
            const fileInputContainer = document.createElement('div');
            fileInputContainer.className = 'file-input-container';
            
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.txt';
            fileInput.id = 'txtFileInput';
            
            const previewDiv = document.createElement('div');
            previewDiv.className = 'import-preview';
            previewDiv.id = 'importPreview';
            previewDiv.style.display = 'none';
            
            fileInput.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    const content = e.target.result;
                    const lines = content.split('\n').filter(line => line.trim());
                    
                    // Show preview
                    previewDiv.innerHTML = '';
                    previewDiv.style.display = 'block';
                    
                    const previewTitle = document.createElement('p');
                    previewTitle.textContent = `Will import ${lines.length} word groups:`;
                    previewDiv.appendChild(previewTitle);
                    
                    lines.forEach((line, index) => {
                        const words = line.trim().split(/\s+/);
                        const previewItem = document.createElement('div');
                        previewItem.className = 'import-preview-item';
                        previewItem.textContent = `Group ${index + 1}: ${words.join(', ')}`;
                        previewDiv.appendChild(previewItem);
                    });
                    
                    // Add import button
                    const importButton = document.createElement('button');
                    importButton.textContent = 'Import Data';
                    importButton.addEventListener('click', () => {
                        importWordsFromTxt(lines);
                    });
                    
                    const cancelButton = document.createElement('button');
                    cancelButton.textContent = 'Cancel';
                    cancelButton.className = 'cancel';
                    cancelButton.addEventListener('click', () => {
                        clearContent();
                        updateStatus("Import canceled");
                    });
                    
                    const buttonGroup = document.createElement('div');
                    buttonGroup.className = 'button-group';
                    buttonGroup.appendChild(importButton);
                    buttonGroup.appendChild(cancelButton);
                    
                    container.appendChild(buttonGroup);
                };
                reader.readAsText(file);
            });
            
            fileInputContainer.appendChild(fileInput);
            container.appendChild(fileInputContainer);
            container.appendChild(previewDiv);
            
            const backButton = document.createElement('button');
            backButton.textContent = 'Back';
            backButton.className = 'cancel';
            backButton.addEventListener('click', () => {
                showImportTxt();
            });
            
            container.appendChild(backButton);
            content.appendChild(container);
            updateStatus("Select TXT file to import");
        }
        
        function showImportVocabStats() {
    clearContent();
    
    const container = document.createElement('div');
    container.className = 'input-container';
    
    const title = document.createElement('h3');
    title.textContent = 'Import Vocabulary Stats';
    container.appendChild(title);
    
    const instructions = document.createElement('p');
    instructions.textContent = 'Select a TXT file (one word per line with status, format: word:status). Status can be "known", "unknown", or "unsure":';
    container.appendChild(instructions);
    
    const fileInputContainer = document.createElement('div');
    fileInputContainer.className = 'file-input-container';
    
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = '.txt';
    fileInput.id = 'txtFileInput';
    
    const previewDiv = document.createElement('div');
    previewDiv.className = 'import-preview';
    previewDiv.id = 'importPreview';
    previewDiv.style.display = 'none';
    
    fileInput.addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = function(e) {
            const content = e.target.result;
            const lines = content.split('\n').filter(line => line.trim());
            
            // Show preview
            previewDiv.innerHTML = '';
            previewDiv.style.display = 'block';
            
            const previewTitle = document.createElement('p');
            previewTitle.textContent = `Found ${lines.length} vocabulary entries:`;
            previewDiv.appendChild(previewTitle);
            
            let validEntries = 0;
            
            lines.forEach((line, index) => {
                const [word, status] = line.trim().split(':');
                const previewItem = document.createElement('div');
                previewItem.className = 'import-preview-item';
                
                if (word && status && ['known','unknown','unsure'].includes(status)) {
                    previewItem.innerHTML = `<span class="correct">‚úì</span> ${word}: ${status}`;
                    validEntries++;
                } else {
                    previewItem.innerHTML = `<span class="incorrect">‚úó</span> Invalid format: ${line}`;
                }
                previewDiv.appendChild(previewItem);
            });
            
            // Add import button only if valid entries found
            if (validEntries > 0) {
                const importButton = document.createElement('button');
                importButton.textContent = `Import ${validEntries} Valid Entries`;
                importButton.addEventListener('click', () => {
                    importVocabStatsFromTxt(lines);
                });
                
                const cancelButton = document.createElement('button');
                cancelButton.textContent = 'Cancel';
                cancelButton.className = 'cancel';
                cancelButton.addEventListener('click', () => {
                    clearContent();
                    updateStatus("Import canceled");
                });
                
                const buttonGroup = document.createElement('div');
                buttonGroup.className = 'button-group';
                buttonGroup.appendChild(importButton);
                buttonGroup.appendChild(cancelButton);
                
                // Clear previous buttons if any
                const oldButtonGroup = container.querySelector('.button-group');
                if (oldButtonGroup) {
                    container.removeChild(oldButtonGroup);
                }
                
                container.appendChild(buttonGroup);
            } else {
                const errorMsg = document.createElement('p');
                errorMsg.className = 'incorrect';
                errorMsg.textContent = 'No valid entries found in the file';
                previewDiv.appendChild(errorMsg);
            }
        };
        reader.readAsText(file);
    });
    
    fileInputContainer.appendChild(fileInput);
    container.appendChild(fileInputContainer);
    container.appendChild(previewDiv);
    
    const backButton = document.createElement('button');
    backButton.textContent = 'Back';
    backButton.className = 'cancel';
    backButton.addEventListener('click', () => {
        showImportTxt();
    });
    
    container.appendChild(backButton);
    content.appendChild(container);
    updateStatus("Select TXT file to import vocabulary stats");
}
    
    function importVocabStatsFromTxt(lines) {
        let importedStats = 0;
        
        for (const line of lines) {
            const [word, status] = line.trim().split(':');
            if (word && status && ['known', 'unknown', 'unsure'].includes(status)) {
                vocabStats[word] = status;
                importedStats++;
            }
        }
        
        if (saveData()) {
            clearContent();
            const successMsg = document.createElement('p');
            successMsg.className = 'correct';
            successMsg.textContent = `Successfully imported ${importedStats} vocabulary stats`;
            content.appendChild(successMsg);
            updateStatus("Import completed");
        } else {
            clearContent();
            const errorMsg = document.createElement('p');
            errorMsg.className = 'incorrect';
            errorMsg.textContent = 'Error during import';
            content.appendChild(errorMsg);
            updateStatus("Import failed");
        }
    }
    
    function importWordsFromTxt(lines) {
        let importedGroups = 0;
        let importedWords = 0;
        
        for (const line of lines) {
            const words = line.trim().split(/\s+/).filter(w => w);
            if (words.length === 0) continue;
            
            // First word as root
            const rootWord = words[0];
            if (!mp.has(rootWord)) {
                mp.set(rootWord, ++cnt);
                bac[cnt] = rootWord;
            }
            
            // Associate other words
            for (let i = 1; i < words.length; i++) {
                const word = words[i];
                if (!mp.has(word)) {
                    mp.set(word, ++cnt);
                    bac[cnt] = word;
                }
                union_set(mp.get(rootWord), mp.get(word));
                importedWords++;
            }
            
            importedGroups++;
        }
        
        if (saveData()) {
            clearContent();
            const successMsg = document.createElement('p');
            successMsg.className = 'correct';
            successMsg.textContent = `Successfully imported ${importedGroups} word groups, ${importedWords} associated words`;
            content.appendChild(successMsg);
            updateStatus("Import completed");
        } else {
            clearContent();
            const errorMsg = document.createElement('p');
            errorMsg.className = 'incorrect';
            errorMsg.textContent = 'Error during import';
            content.appendChild(errorMsg);
            updateStatus("Import failed");
        }
    }
    
    function showExportTxt() {
        if (mp.size === 0 && Object.keys(vocabStats).length === 0) {
            const errorMsg = document.createElement('p');
            errorMsg.className = 'incorrect';
            errorMsg.textContent = 'No data to export';
            content.appendChild(errorMsg);
            updateStatus("No data available");
            return;
        }
        
        clearContent();
        
        const container = document.createElement('div');
        container.className = 'input-container';
        
        const title = document.createElement('h3');
        title.textContent = 'Export TXT File';
        container.appendChild(title);
        
        const instructions = document.createElement('p');
        instructions.textContent = 'Select export type:';
        container.appendChild(instructions);
        
        const optionsDiv = document.createElement('div');
        optionsDiv.className = 'export-options';
        
        // Option 1: Export word groups
        const option1 = document.createElement('div');
        option1.className = 'export-option';
        option1.innerHTML = `
            <h4>Word Groups</h4>
            <p>Export all word groups (one group per line)</p>
        `;
        option1.addEventListener('click', () => {
            exportAllGroups();
        });
        
        // Option 2: Export vocabulary stats
        const option2 = document.createElement('div');
        option2.className = 'export-option';
        option2.innerHTML = `
            <h4>Vocabulary Stats</h4>
            <p>Export known/unknown/unsure words (one word per line with status)</p>
        `;
        option2.addEventListener('click', () => {
            exportVocabStats();
        });
        
        optionsDiv.appendChild(option1);
        optionsDiv.appendChild(option2);
        container.appendChild(optionsDiv);
        
        const backButton = document.createElement('button');
        backButton.textContent = 'Back';
        backButton.className = 'cancel';
        backButton.addEventListener('click', () => {
            clearContent();
            updateStatus("Export canceled");
        });
        
        container.appendChild(backButton);
        content.appendChild(container);
        updateStatus("Select export type");
    }
    
    function exportAllGroups() {
        const printedGroups = new Set();
        let exportContent = '';
        
        for (let i = 1; i <= cnt; i++) {
            if (!mp.has(bac[i])) continue;
            
            const root = find(i);
            if (printedGroups.has(root)) continue;
            printedGroups.add(root);
            
            const groupWords = [];
            for (const [w, id] of mp) {
                if (find(id) === root) {
                    groupWords.push(w);
                }
            }
            
            exportContent += groupWords.join(' ') + '\n\n'; // Add extra newline between groups
        }

        // Create download link
        const blob = new Blob([exportContent], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'all_word_groups.txt';
        
        clearContent();
        
        const successDiv = document.createElement('div');
        successDiv.innerHTML = `
            <p class="correct">Ready to export ${printedGroups.size} word groups</p>
            <p>Click the button below to download</p>
        `;
        content.appendChild(successDiv);
        
        const downloadButton = document.createElement('button');
        downloadButton.textContent = 'Download TXT File';
        downloadButton.addEventListener('click', () => {
            a.click();
            URL.revokeObjectURL(url);
            
            const doneMsg = document.createElement('p');
            doneMsg.className = 'correct';
            doneMsg.textContent = 'Export completed!';
            content.appendChild(doneMsg);
            
            downloadButton.disabled = true;
            updateStatus("Export completed");
        });
        
        content.appendChild(downloadButton);
        
        const backButton = document.createElement('button');
        backButton.textContent = 'Back';
        backButton.className = 'cancel';
        backButton.addEventListener('click', () => {
            showExportTxt();
        });
        
        content.appendChild(backButton);
        updateStatus("Ready to export all word groups");
    }
    
    function exportVocabStats() {
        let exportContent = '';
        
        for (const [word, status] of Object.entries(vocabStats)) {
            exportContent += `${word}:${status}\n`;
        }

        // Create download link
        const blob = new Blob([exportContent], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'vocabulary_stats.txt';
        
        clearContent();
        
        const successDiv = document.createElement('div');
        successDiv.innerHTML = `
            <p class="correct">Ready to export ${Object.keys(vocabStats).length} vocabulary stats</p>
            <p>Click the button below to download</p>
        `;
        content.appendChild(successDiv);
        
        const downloadButton = document.createElement('button');
        downloadButton.textContent = 'Download TXT File';
        downloadButton.addEventListener('click', () => {
            a.click();
            URL.revokeObjectURL(url);
            
            const doneMsg = document.createElement('p');
            doneMsg.className = 'correct';
            doneMsg.textContent = 'Export completed!';
            content.appendChild(doneMsg);
            
            downloadButton.disabled = true;
            updateStatus("Export completed");
        });
        
        content.appendChild(downloadButton);
        
        const backButton = document.createElement('button');
        backButton.textContent = 'Back';
        backButton.className = 'cancel';
        backButton.addEventListener('click', () => {
            showExportTxt();
        });
        
        content.appendChild(backButton);
        updateStatus("Ready to export vocabulary stats");
    }
    
    function showRecycleBin() {
    clearContent();

    const title = document.createElement('h3');
    title.textContent = 'Recycle Bin';
    content.appendChild(title);

    if (recycleBin.length === 0) {
        const emptyMsg = document.createElement('p');
        emptyMsg.textContent = 'Recycle bin is empty';
        content.appendChild(emptyMsg);
    } else {
        // 1. Ê∑ªÂä†Ê∏ÖÁ©∫ÊåâÈíÆÔºàÂõ∫ÂÆöÂú®È°∂ÈÉ®Ôºâ
        const clearAllBtn = document.createElement('button');
        clearAllBtn.textContent = 'üóëÔ∏è Empty Recycle Bin';
        clearAllBtn.className = 'cancel';
        clearAllBtn.style.marginBottom = '20px';
        clearAllBtn.onclick = () => {
            showConfirm("Permanently delete ALL items in recycle bin?", (confirmed) => {
                if (confirmed) {
                    recycleBin = [];
                    saveData();
                    clearContent();
                    const successMsg = document.createElement('p');
                    successMsg.className = 'correct';
                    successMsg.textContent = 'Recycle bin emptied successfully';
                    content.appendChild(successMsg);
                    setTimeout(() => showRecycleBin(), 1500);
                }
            });
        };
        content.appendChild(clearAllBtn);

        // 2. ÊòæÁ§∫ÊâÄÊúâÂõûÊî∂Á´ôÈ°πÁõÆ
        recycleBin.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp)).forEach((item, index) => {
            const binItem = document.createElement('div');
            binItem.className = 'recycle-bin-item';

            let itemText;
            if (item.word === "ALL_WORDS") {
                itemText = `Cleared all words (${item.group.length} words)`;
            } else if (item.group[0] === "STATUS_DELETION") {
                itemText = `Removed "${item.word}" from ${item.source}`;
            } else if (item.group.length > 1) {
                itemText = `Deleted word group: ${item.group.join(', ')}`;
            } else {
                itemText = `Deleted word: "${item.word}"`;
            }

            binItem.innerHTML = `
                <div>
                    <div>${itemText}</div>
                    <div class="recycle-bin-meta">
                        ${new Date(item.timestamp).toLocaleString()} ‚Ä¢ ${item.source}
                    </div>
                </div>
                <div class="recycle-bin-actions">
                    <button class="restore-btn">‚Üª Restore</button>
                    <button class="cancel">‚úï Delete</button>
                </div>
            `;

            // ÊÅ¢Â§çÂäüËÉΩ
            binItem.querySelector('.restore-btn').addEventListener('click', () => {
                restoreFromRecycleBin(index);
            });

            // Ê∞∏‰πÖÂà†Èô§
            binItem.querySelector('.cancel').addEventListener('click', () => {
                showConfirm("Permanently delete this item?", (confirmed) => {
                    if (confirmed) {
                        recycleBin.splice(index, 1);
                        saveData();
                        showRecycleBin();
                    }
                });
            });

            content.appendChild(binItem);
        });
    }

    // ËøîÂõûÊåâÈíÆ
    const backButton = document.createElement('button');
    backButton.textContent = '‚Üê Back';
    backButton.className = 'cancel';
    backButton.style.marginTop = '20px';
    backButton.addEventListener('click', () => {
        handleMenuChoice(currentChoice);
    });
    content.appendChild(backButton);
}
    
    function showAdminLogin() {
    clearContent();
    
    const container = document.createElement('div');
    container.className = 'input-container';
    
    const title = document.createElement('h3');
    title.textContent = 'Admin Login';
    container.appendChild(title);
    
    const usernameLabel = document.createElement('label');
    usernameLabel.textContent = 'Username:';
    container.appendChild(usernameLabel);
    
    const usernameInput = document.createElement('input');
    usernameInput.type = 'text';
    usernameInput.placeholder = 'Enter username...';
    container.appendChild(usernameInput);
    
    const passwordLabel = document.createElement('label');
    passwordLabel.textContent = 'Password:';
    container.appendChild(passwordLabel);
    
    const passwordInput = document.createElement('input');
    passwordInput.type = 'password';
    passwordInput.placeholder = 'Enter password...';
    container.appendChild(passwordInput);
    
    const buttonGroup = document.createElement('div');
    buttonGroup.className = 'button-group';
    
    const loginButton = document.createElement('button');
    loginButton.textContent = 'Login';
    loginButton.addEventListener('click', () => {
        const username = usernameInput.value.trim();
        const password = passwordInput.value.trim();
        
        if (username === ADMIN_PASSWORD.username && password === ADMIN_PASSWORD.password) {
            isAdmin = true;
            updateStatus("Admin logged in");
            showBulletinBoard();
        } else {
            const errorMsg = document.createElement('p');
            errorMsg.className = 'incorrect';
            errorMsg.textContent = 'Invalid username or password';
            container.appendChild(errorMsg);
            updateStatus("Login failed");
        }
    });
    
    const cancelButton = document.createElement('button');
    cancelButton.textContent = 'Cancel';
    cancelButton.className = 'cancel';
    cancelButton.addEventListener('click', () => {
        showBulletinBoard();
    });
    
    buttonGroup.appendChild(loginButton);
    buttonGroup.appendChild(cancelButton);
    container.appendChild(buttonGroup);
    
    content.appendChild(container);
    usernameInput.focus();
}

function showNewAnnouncement(editIndex = null) {
    clearContent();
    
    const container = document.createElement('div');
    container.className = 'input-container';
    
    const title = document.createElement('h3');
    title.textContent = editIndex === null ? 'New Announcement' : 'Edit Announcement';
    container.appendChild(title);
    
    const titleLabel = document.createElement('label');
    titleLabel.textContent = 'Title:';
    container.appendChild(titleLabel);
    
    const titleInput = document.createElement('input');
    titleInput.type = 'text';
    titleInput.placeholder = 'Enter title...';
    if (editIndex !== null) {
        titleInput.value = bulletinBoard[editIndex].title;
    }
    container.appendChild(titleInput);
    
    const contentLabel = document.createElement('label');
    contentLabel.textContent = 'Content:';
    container.appendChild(contentLabel);
    
    const contentInput = document.createElement('textarea');
    contentInput.placeholder = 'Enter content...';
    if (editIndex !== null) {
        contentInput.value = bulletinBoard[editIndex].content;
    }
    container.appendChild(contentInput);
    
    const buttonGroup = document.createElement('div');
    buttonGroup.className = 'button-group';
    
    const saveButton = document.createElement('button');
    saveButton.textContent = editIndex === null ? 'Publish' : 'Save Changes';
    saveButton.addEventListener('click', () => {
        const title = titleInput.value.trim();
        const content = contentInput.value.trim();
        
        if (!title || !content) {
            const errorMsg = document.createElement('p');
            errorMsg.className = 'incorrect';
            errorMsg.textContent = 'Title and content are required';
            container.appendChild(errorMsg);
            return;
        }
        
        if (editIndex === null) {
            // New announcement
            bulletinBoard.push({
                title: title,
                content: content,
                author: ADMIN_PASSWORD.username,
                timestamp: new Date().toISOString()
            });
        } else {
            // Edit existing announcement
            bulletinBoard[editIndex] = {
                title: title,
                content: content,
                author: bulletinBoard[editIndex].author, // Keep original author
                timestamp: bulletinBoard[editIndex].timestamp // Keep original timestamp
            };
        }
        
        saveData();
        showBulletinBoard();
    });
    
    const cancelButton = document.createElement('button');
    cancelButton.textContent = 'Cancel';
    cancelButton.className = 'cancel';
    cancelButton.addEventListener('click', () => {
        showBulletinBoard();
    });
    
    buttonGroup.appendChild(saveButton);
    buttonGroup.appendChild(cancelButton);
    container.appendChild(buttonGroup);
    
    content.appendChild(container);
    titleInput.focus();
}

function showBackgroundCustomizer() {
   clearContent();
    
    const container = document.createElement('div');
    container.className = 'input-container';
    
    const title = document.createElement('h3');
    title.textContent = 'Customize Background';
    container.appendChild(title);

    // ÂõæÊ†áËá™ÂÆö‰πâÈÉ®ÂàÜ
    const iconTitle = document.createElement('h4');
    iconTitle.textContent = 'Custom Icon:';
    container.appendChild(iconTitle);

    const iconFileInput = document.createElement('input');
    iconFileInput.type = 'file';
    iconFileInput.id = 'iconFileUpload';
    iconFileInput.accept = 'image/*';
    iconFileInput.style.display = 'none'; // ÈöêËóèÂÆûÈôÖÁöÑÊñá‰ª∂ËæìÂÖ•
    
    // Â∞ÜÊñá‰ª∂ËæìÂÖ•Ê∑ªÂä†Âà∞ÂÆπÂô®‰∏≠
    container.appendChild(iconFileInput);
    
    const iconFileLabel = document.createElement('label');
    iconFileLabel.htmlFor = 'iconFileUpload';
    iconFileLabel.className = 'custom-bg-label';
    iconFileLabel.textContent = 'Upload Custom Icon';
    container.appendChild(iconFileLabel);

    iconFileInput.addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        if (!file.type.match('image.*')) {
            updateStatus("Please select an image file");
            return;
        }
        
        const reader = new FileReader();
        reader.onload = function(e) {
            const iconUrl = e.target.result;
            const link = document.querySelector("link[rel~='icon']");
            if (link) {
                link.href = iconUrl;
            } else {
                const newLink = document.createElement("link");
                newLink.rel = "icon";
                newLink.href = iconUrl;
                document.head.appendChild(newLink);
            }
            localStorage.setItem('vocab_custom_icon', iconUrl);
            updateStatus("Custom icon set");
        };
        reader.readAsDataURL(file);
    });

    const resetIconButton = document.createElement('button');
    resetIconButton.textContent = 'Reset to Default Icon';
    resetIconButton.className = 'cancel';
    resetIconButton.style.marginBottom = '20px';
    resetIconButton.addEventListener('click', () => {
        const link = document.querySelector("link[rel~='icon']");
        if (link) {
            document.head.removeChild(link);
        }
        localStorage.removeItem('vocab_custom_icon');
        updateStatus("Icon reset to default");
    });
    container.appendChild(resetIconButton);

    // Êñ∞Â¢ûÔºöÈÄèÊòéÂ∫¶Ë∞ÉËäÇÈÉ®ÂàÜ
    const opacityTitle = document.createElement('h4');
    opacityTitle.textContent = 'Background Opacity:';
    container.appendChild(opacityTitle);

    const opacitySlider = document.createElement('input');
    opacitySlider.type = 'range';
    opacitySlider.min = '10';
    opacitySlider.max = '100';
    opacitySlider.value = localStorage.getItem('vocab_bg_opacity') || '100';
    opacitySlider.id = 'bgOpacitySlider';
    opacitySlider.style.width = '100%';
    opacitySlider.style.margin = '10px 0';
    container.appendChild(opacitySlider);

    const opacityValue = document.createElement('div');
    opacityValue.textContent = `Opacity: ${opacitySlider.value}%`;
    container.appendChild(opacityValue);

    opacitySlider.addEventListener('input', function() {
        opacityValue.textContent = `Opacity: ${this.value}%`;
        document.body.style.opacity = `${this.value / 100}`;
        localStorage.setItem('vocab_bg_opacity', this.value);
    });

    // ÂéüÊúâÁöÑËÉåÊôØÈ¢ÑËÆæÂíåËá™ÂÆö‰πâËÉåÊôØ‰ª£Á†Å‰øùÊåÅ‰∏çÂèò...
    const presetsTitle = document.createElement('h4');
    presetsTitle.textContent = 'Preset Backgrounds:';
    container.appendChild(presetsTitle);
    
    const presetsDiv = document.createElement('div');
    presetsDiv.className = 'background-options';
    
    const presetColors = [
        {name: 'Dark', color: '#1a1a1a'},
        {name: 'Darker', color: '#0a0a0a'},
        {name: 'Blue', color: '#0d1b2a'},
        {name: 'Navy', color: '#1b263b'},
        {name: 'Purple', color: '#231942'},
        {name: 'Green', color: '#1b4332'}
    ];
    
    presetColors.forEach(preset => {
        const option = document.createElement('div');
        option.className = 'background-option';
        option.style.backgroundColor = preset.color;
        option.title = preset.name;
        option.dataset.color = preset.color;
        option.addEventListener('click', () => {
            document.body.style.background = preset.color;
            localStorage.setItem('vocab_bg_color', preset.color);
            updateStatus(`Background set to ${preset.name}`);
        });
        presetsDiv.appendChild(option);
    });
    
    container.appendChild(presetsDiv);
    
    const customTitle = document.createElement('h4');
    customTitle.textContent = 'Custom Background:';
    container.appendChild(customTitle);
    
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.id = 'customBgUpload';
    fileInput.accept = 'image/*';
    
    const fileLabel = document.createElement('label');
    fileLabel.htmlFor = 'customBgUpload';
    fileLabel.className = 'custom-bg-label';
    fileLabel.textContent = 'Upload Image';
    container.appendChild(fileLabel);
    
    fileInput.addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        if (!file.type.match('image.*')) {
            updateStatus("Please select an image file");
            return;
        }
        
        const reader = new FileReader();
        reader.onload = function(e) {
            const imgUrl = e.target.result;
            document.body.style.backgroundImage = `url(${imgUrl})`;
            document.body.style.backgroundSize = 'cover';
            document.body.style.backgroundAttachment = 'fixed';
            localStorage.setItem('vocab_bg_image', imgUrl);
            updateStatus("Custom background image set");
        };
        reader.readAsDataURL(file);
    });
    
    container.appendChild(fileInput);
    
    const resetButton = document.createElement('button');
    resetButton.textContent = 'Reset to Default';
    resetButton.className = 'cancel';
    resetButton.addEventListener('click', () => {
        document.body.style.background = '#1a1a1a';
        document.body.style.backgroundImage = '';
        document.body.style.opacity = '1';
        localStorage.removeItem('vocab_bg_color');
        localStorage.removeItem('vocab_bg_image');
        localStorage.removeItem('vocab_bg_opacity');
        updateStatus("Background reset to default");
    });
    
    container.appendChild(resetButton);
    
    const backButton = document.createElement('button');
    backButton.textContent = 'Back';
    backButton.className = 'cancel';
    backButton.addEventListener('click', () => {
        clearContent();
        updateStatus("Returned to main menu");
    });
    
    container.appendChild(backButton);
    content.appendChild(container);
    
    // Âä†ËΩΩ‰øùÂ≠òÁöÑËÆæÁΩÆ
    const savedColor = localStorage.getItem('vocab_bg_color');
    const savedImage = localStorage.getItem('vocab_bg_image');
    const savedOpacity = localStorage.getItem('vocab_bg_opacity');
    const savedIcon = localStorage.getItem('vocab_custom_icon');
    
    if (savedColor) {
        document.body.style.background = savedColor;
    } else if (savedImage) {
        document.body.style.backgroundImage = `url(${savedImage})`;
        document.body.style.backgroundSize = 'cover';
        document.body.style.backgroundAttachment = 'fixed';
    }
    
    if (savedOpacity) {
        document.body.style.opacity = `${savedOpacity / 100}`;
        opacitySlider.value = savedOpacity;
        opacityValue.textContent = `Opacity: ${savedOpacity}%`;
    }
    
    if (savedIcon) {
        const link = document.querySelector("link[rel~='icon']") || document.createElement("link");
        link.rel = "icon";
        link.href = savedIcon;
        document.head.appendChild(link);
    }
}

// Modified bulletin board item creation in showBulletinBoard()
function showBulletinBoard() {
    clearContent();
    
    const title = document.createElement('h3');
    title.textContent = 'Bulletin Board';
    content.appendChild(title);
    
    if (bulletinBoard.length === 0) {
        const emptyMsg = document.createElement('p');
        emptyMsg.textContent = 'No announcements yet.';
        content.appendChild(emptyMsg);
    } else {
        const boardDiv = document.createElement('div');
        boardDiv.className = 'bulletin-board';
        
        // Sort by timestamp (newest first)
        bulletinBoard.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
        
        bulletinBoard.forEach((item, index) => {
            const bulletinItem = document.createElement('div');
            bulletinItem.className = 'bulletin-item';
            
            const titleDiv = document.createElement('div');
            titleDiv.className = 'bulletin-title';
            titleDiv.textContent = item.title;
            titleDiv.style.cursor = 'pointer';
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'bulletin-content';
            contentDiv.textContent = item.content;
            
            const metaDiv = document.createElement('div');
            metaDiv.className = 'bulletin-meta';
            metaDiv.textContent = `Posted by ${item.author} on ${new Date(item.timestamp).toLocaleString()}`;
            
            // Toggle content visibility when clicking title
            titleDiv.addEventListener('click', () => {
                if (contentDiv.style.display === 'none') {
                    contentDiv.style.display = 'block';
                    metaDiv.style.display = 'block';
                    titleDiv.classList.remove('collapsed');
                    if (isAdmin && bulletinItem.querySelector('.admin-controls')) {
                        bulletinItem.querySelector('.admin-controls').style.display = 'flex';
                    }
                } else {
                    contentDiv.style.display = 'none';
                    metaDiv.style.display = 'none';
                    titleDiv.classList.add('collapsed');
                    if (isAdmin && bulletinItem.querySelector('.admin-controls')) {
                        bulletinItem.querySelector('.admin-controls').style.display = 'none';
                    }
                }
            });
            
            bulletinItem.appendChild(titleDiv);
            bulletinItem.appendChild(contentDiv);
            bulletinItem.appendChild(metaDiv);
            
            if (isAdmin) {
                const adminControls = document.createElement('div');
                adminControls.className = 'admin-controls';
                
                const editButton = document.createElement('button');
                editButton.textContent = 'Edit';
                editButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    showNewAnnouncement(index);
                });
                
                const deleteButton = document.createElement('button');
                deleteButton.textContent = 'Delete';
                deleteButton.className = 'cancel';
                deleteButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    showConfirm("Delete this announcement?", (confirmed) => {
                        if (confirmed) {
                            bulletinBoard.splice(index, 1);
                            saveData();
                            showBulletinBoard();
                        }
                    });
                });
                
                adminControls.appendChild(editButton);
                adminControls.appendChild(deleteButton);
                bulletinItem.appendChild(adminControls);
            }
            
            boardDiv.appendChild(bulletinItem);
        });
        
        content.appendChild(boardDiv);
    }
    
    const buttonGroup = document.createElement('div');
    buttonGroup.className = 'button-group';
    
    if (isAdmin) {
        const newButton = document.createElement('button');
        newButton.textContent = 'New Announcement';
        newButton.addEventListener('click', () => {
            showNewAnnouncement();
        });
        buttonGroup.appendChild(newButton);
        
        const logoutButton = document.createElement('button');
        logoutButton.textContent = 'Logout';
        logoutButton.className = 'cancel';
        logoutButton.addEventListener('click', () => {
            isAdmin = false;
            showBulletinBoard();
            updateStatus("Admin logged out");
        });
        buttonGroup.appendChild(logoutButton);
    } else {
        const adminButton = document.createElement('button');
        adminButton.textContent = 'Admin Login';
        adminButton.addEventListener('click', () => {
            showAdminLogin();
        });
        buttonGroup.appendChild(adminButton);
    }
    
    const backButton = document.createElement('button');
    backButton.textContent = 'Back';
    backButton.className = 'cancel';
    backButton.addEventListener('click', () => {
        clearContent();
        updateStatus("Returned to main menu");
    });
    
    buttonGroup.appendChild(backButton);
    content.appendChild(buttonGroup);
    updateStatus(`Bulletin board (${bulletinBoard.length} announcements)`);
}    

    function showTextAnalyzer() {
        clearContent();
        
        const container = document.createElement('div');
        container.className = 'input-container';
        
        const title = document.createElement('h3');
        title.textContent = 'Text Analyzer';
        container.appendChild(title);
        
        const instructions = document.createElement('p');
        instructions.textContent = 'Paste text to analyze for vocabulary words (will ignore case and punctuation):';
        container.appendChild(instructions);
        
        const textarea = document.createElement('textarea');
        textarea.placeholder = 'Paste your text here...';
        container.appendChild(textarea);
        
        const buttonGroup = document.createElement('div');
        buttonGroup.className = 'button-group';
        
        const analyzeButton = document.createElement('button');
        analyzeButton.textContent = 'Analyze';
        analyzeButton.addEventListener('click', () => {
            const text = textarea.value.trim();
            if (text) {
                analyzeText(text);
            }
        });
        
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.className = 'cancel';
        cancelButton.addEventListener('click', () => {
            clearContent();
            updateStatus("Analysis canceled");
        });
        
        buttonGroup.appendChild(analyzeButton);
        buttonGroup.appendChild(cancelButton);
        container.appendChild(buttonGroup);
        
        content.appendChild(container);
        textarea.focus();
    }
    
    function analyzeText(text) {
    // Normalize text - lowercase and remove punctuation except apostrophes and hyphens
    const normalizedText = text.toLowerCase()
        .replace(/[0-9.,\/#!$%\^&\*;:{}=\_`~()?"]/g, '') // Remove numbers and punctuation except apostrophes and hyphens
        .replace(/\s+/g, ' '); // Normalize whitespace
    
    const words = normalizedText.split(/\s+/).filter(w => w);
    
    const knownWords = new Set();
    const unsureWords = new Set();
    const unknownWords = new Set();
    const newWords = new Set();
    
    // Create progress bar
    const progressContainer = document.createElement('div');
    progressContainer.className = 'analyze-progress';
    const progressBar = document.createElement('div');
    progressBar.className = 'progress-bar';
    progressContainer.appendChild(progressBar);
    content.appendChild(progressContainer);
    
    // Analyze words with progress feedback
    let analyzedCount = 0;
    const totalWords = words.length;
    
    const analyzeInterval = setInterval(() => {
        if (analyzedCount >= totalWords) {
            clearInterval(analyzeInterval);
            showAnalysisResults(knownWords, unsureWords, unknownWords, newWords);
            return;
        }
        
        const word = words[analyzedCount];
        
        // Check word status
        if (vocabStats[word]) {
            if (vocabStats[word] === 'known') {
                knownWords.add(word);
            } else if (vocabStats[word] === 'unsure') {
                unsureWords.add(word);
            } else if (vocabStats[word] === 'unknown') {
                unknownWords.add(word);
            }
        } else {
            newWords.add(word);
        }
        
        analyzedCount++;
        progressBar.style.width = `${(analyzedCount / totalWords) * 100}%`;
    }, 10);
}
    
   function showAnalysisResults(knownWords, unsureWords, unknownWords, newWords) {
    clearContent();
    
    const title = document.createElement('h3');
    title.textContent = 'Text Analysis Results';
    content.appendChild(title);
    
    const statsDiv = document.createElement('div');
    statsDiv.className = 'word-stats';
    
    const totalRecognized = knownWords.size + unsureWords.size + unknownWords.size + newWords.size;
    const totalRecorded = knownWords.size + unsureWords.size + unknownWords.size;
    
    statsDiv.innerHTML = `
        <p>Total words recognized: ${totalRecognized}</p>
        <p>Recorded words: ${totalRecorded} (${knownWords.size} known, ${unsureWords.size + unknownWords.size} unknown)</p>
        <p>${newWords.size} new words to process</p>
    `;
    content.appendChild(statsDiv);
    
    if (newWords.size > 0) {
        const newTitle = document.createElement('h4');
        newTitle.textContent = 'New words:';
        content.appendChild(newTitle);
        
        const wordList = document.createElement('div');
        wordList.className = 'word-list';
        
        Array.from(newWords).forEach(word => {
            const wordItem = document.createElement('div');
            wordItem.className = 'vocab-word';
            
            const wordText = document.createElement('span');
            wordText.textContent = word;
            
            const statusControls = document.createElement('div');
            statusControls.className = 'word-status';
            
            const knownBtn = document.createElement('button');
            knownBtn.textContent = 'Known';
            knownBtn.className = 'status-btn status-known';
            knownBtn.addEventListener('click', () => {
                updateWordStatus(word, 'known');
                wordItem.remove();
                statsDiv.innerHTML = `
                    <p>Total words recognized: ${totalRecognized}</p>
                    <p>Recorded words: ${totalRecorded + 1} (${knownWords.size + 1} known, ${unsureWords.size + unknownWords.size} unknown)</p>
                    <p>${newWords.size - 1} new words to process</p>
                `;
            });
            
            const unsureBtn = document.createElement('button');
            unsureBtn.textContent = 'Unsure';
            unsureBtn.className = 'status-btn status-unsure';
            unsureBtn.addEventListener('click', () => {
                updateWordStatus(word, 'unsure');
                wordItem.remove();
                statsDiv.innerHTML = `
                    <p>Total words recognized: ${totalRecognized}</p>
                    <p>Recorded words: ${totalRecorded + 1} (${knownWords.size} known, ${unsureWords.size + unknownWords.size + 1} unknown)</p>
                    <p>${newWords.size - 1} new words to process</p>
                `;
            });
            
            const unknownBtn = document.createElement('button');
            unknownBtn.textContent = 'Unknown';
            unknownBtn.className = 'status-btn status-unknown';
            unknownBtn.addEventListener('click', () => {
                updateWordStatus(word, 'unknown');
                wordItem.remove();
                statsDiv.innerHTML = `
                    <p>Total words recognized: ${totalRecognized}</p>
                    <p>Recorded words: ${totalRecorded + 1} (${knownWords.size} known, ${unsureWords.size + unknownWords.size + 1} unknown)</p>
                    <p>${newWords.size - 1} new words to process</p>
                `;
            });
            
            statusControls.appendChild(knownBtn);
            statusControls.appendChild(unsureBtn);
            statusControls.appendChild(unknownBtn);
            
            wordItem.appendChild(wordText);
            wordItem.appendChild(statusControls);
            wordList.appendChild(wordItem);
        });
        
        content.appendChild(wordList);
    }
    
    if (knownWords.size > 0 || unsureWords.size > 0 || unknownWords.size > 0) {
        const recordedTitle = document.createElement('h4');
        recordedTitle.textContent = 'Recorded words:';
        content.appendChild(recordedTitle);
        
        const recordedDiv = document.createElement('div');
        
        if (knownWords.size > 0) {
            const knownTitle = document.createElement('h5');
            knownTitle.className = 'correct';
            knownTitle.textContent = `Known (${knownWords.size}):`;
            recordedDiv.appendChild(knownTitle);
            
            const knownGroup = document.createElement('div');
            knownGroup.className = 'word-group';
            Array.from(knownWords).forEach(word => {
                const wordSpan = document.createElement('span');
                wordSpan.className = 'word-item correct';
                wordSpan.textContent = word;
                knownGroup.appendChild(wordSpan);
            });
            recordedDiv.appendChild(knownGroup);
        }
        
        if (unsureWords.size > 0) {
            const unsureTitle = document.createElement('h5');
            unsureTitle.className = 'status-unsure';
            unsureTitle.textContent = `Unsure (${unsureWords.size}):`;
            recordedDiv.appendChild(unsureTitle);
            
            const unsureGroup = document.createElement('div');
            unsureGroup.className = 'word-group';
            Array.from(unsureWords).forEach(word => {
                const wordSpan = document.createElement('span');
                wordSpan.className = 'word-item status-unsure';
                wordSpan.textContent = word;
                unsureGroup.appendChild(wordSpan);
            });
            recordedDiv.appendChild(unsureGroup);
        }
        
        if (unknownWords.size > 0) {
            const unknownTitle = document.createElement('h5');
            unknownTitle.className = 'incorrect';
            unknownTitle.textContent = `Unknown (${unknownWords.size}):`;
            recordedDiv.appendChild(unknownTitle);
            
            const unknownGroup = document.createElement('div');
            unknownGroup.className = 'word-group';
            Array.from(unknownWords).forEach(word => {
                const wordSpan = document.createElement('span');
                wordSpan.className = 'word-item incorrect';
                wordSpan.textContent = word;
                unknownGroup.appendChild(wordSpan);
            });
            recordedDiv.appendChild(unknownGroup);
        }
        
        content.appendChild(recordedDiv);
    }
    
    const backButton = document.createElement('button');
    backButton.textContent = 'Back';
    backButton.className = 'cancel';
    backButton.addEventListener('click', () => {
        clearContent();
        updateStatus("Returned to main menu");
    });
    
    content.appendChild(backButton);
    updateStatus("Analysis completed");
}
    
    function updateWordStatus(word, status) {
    const prevStatus = vocabStats[word];
    vocabStats[word] = status;
    
    if (saveData()) {
        // Show feedback message
        const feedback = document.createElement('div');
        feedback.className = 'status-bar';
        feedback.innerHTML = `
            <p class="correct">‚úì "${word}" status changed from 
            ${prevStatus || 'unmarked'} to ${status}</p>
        `;
        
        // Insert at top of content
        if (content.firstChild) {
            content.insertBefore(feedback, content.firstChild);
        } else {
            content.appendChild(feedback);
        }
        
        // Scroll to top to show feedback
        content.scrollTop = 0;
        
        // Remove feedback after 3 seconds
        setTimeout(() => {
            feedback.remove();
        }, 3000);
    }
}
    
	function showReviewSetup() {
    clearContent();
    
    const container = document.createElement('div');
    container.className = 'input-container';
    
    const title = document.createElement('h3');
    title.textContent = 'Vocabulary Review';
    container.appendChild(title);
    
    // Show review stats
    const stats = calculateReviewStats();
    const statsDiv = document.createElement('div');
    statsDiv.className = 'word-stats';
    statsDiv.innerHTML = `
        <p>Words to review: ${stats.totalUnknown + stats.totalUnsure}</p>
        <p>Unknown words: ${stats.totalUnknown}</p>
        <p>Unsure words: ${stats.totalUnsure}</p>
        <p>Words reviewed today: ${stats.reviewedToday}</p>
    `;
    container.appendChild(statsDiv);
    
    // Daily goal input
    const goalLabel = document.createElement('label');
    goalLabel.textContent = 'Daily review goal (words):';
    container.appendChild(goalLabel);
    
    const goalInput = document.createElement('input');
    goalInput.type = 'number';
    goalInput.min = '1';
    goalInput.value = '20';
    goalInput.id = 'dailyGoal';
    container.appendChild(goalInput);
    
    const buttonGroup = document.createElement('div');
    buttonGroup.className = 'button-group';
    
    const startButton = document.createElement('button');
    startButton.textContent = 'Start Review';
    startButton.addEventListener('click', () => {
        const dailyGoal = parseInt(goalInput.value) || 20;
        startReviewSession(dailyGoal);
    });
    
    const cancelButton = document.createElement('button');
    cancelButton.textContent = 'Cancel';
    cancelButton.className = 'cancel';
    cancelButton.addEventListener('click', () => {
        clearContent();
        updateStatus("Review canceled");
    });
    
    buttonGroup.appendChild(startButton);
    buttonGroup.appendChild(cancelButton);
    container.appendChild(buttonGroup);
    
    content.appendChild(container);
    updateStatus("Ready for vocabulary review");
}

function calculateReviewStats() {
    const today = new Date().toISOString().split('T')[0];
    let reviewedToday = 0;
    let totalUnknown = 0;
    let totalUnsure = 0;
    
    // Get words from vocabStats
    for (const [word, status] of Object.entries(vocabStats)) {
        if (status === 'unknown') totalUnknown++;
        if (status === 'unsure') totalUnsure++;
        
        // Check if word was reviewed today
        const wordData = localStorage.getItem(`word_review_${word}`);
        if (wordData) {
            const { lastReviewed } = JSON.parse(wordData);
            if (lastReviewed && lastReviewed.startsWith(today)) {
                reviewedToday++;
            }
        }
    }
    
    return {
        reviewedToday,
        totalUnknown,
        totalUnsure
    };
}

function startReviewSession(dailyGoal) {
    clearContent();
    
    // Get words to review (unknown and unsure)
    const unknownWords = [];
    const unsureWords = [];
    
    for (const [word, status] of Object.entries(vocabStats)) {
        if (status === 'unknown') unknownWords.push(word);
        if (status === 'unsure') unsureWords.push(word);
    }
    
    if (unknownWords.length === 0 && unsureWords.length === 0) {
        const noWordsMsg = document.createElement('p');
        noWordsMsg.className = 'incorrect';
        noWordsMsg.textContent = 'No words to review (mark words as unknown/unsure first)';
        content.appendChild(noWordsMsg);
        return;
    }
    
    // Calculate how many words to review from each category (3:2 ratio)
    const totalWords = Math.min(dailyGoal, unknownWords.length + unsureWords.length);
    const unknownCount = Math.min(
        Math.ceil(totalWords * 0.6),
        unknownWords.length
    );
    const unsureCount = Math.min(
        totalWords - unknownCount,
        unsureWords.length
    );
    
    // Select random words for review
    const selectedWords = [];
    
    // Shuffle arrays
    shuffleArray(unknownWords);
    shuffleArray(unsureWords);
    
    // Add unknown words
    for (let i = 0; i < unknownCount; i++) {
        selectedWords.push({
            word: unknownWords[i],
            originalStatus: 'unknown'
        });
    }
    
    // Add unsure words
    for (let i = 0; i < unsureCount; i++) {
        selectedWords.push({
            word: unsureWords[i],
            originalStatus: 'unsure'
        });
    }
    
    // Shuffle the final selection
    shuffleArray(selectedWords);
    
    // Start review
    reviewNextWord(selectedWords, 0, totalWords);
}

function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}

function reviewNextWord(words, index, dailyGoal) {
    if (index >= words.length) {
        // Review completed
        clearContent();
        const completeMsg = document.createElement('p');
        completeMsg.className = 'correct';
        completeMsg.textContent = `Review completed! You reviewed ${index} words today.`;
        content.appendChild(completeMsg);
        
        const backButton = document.createElement('button');
        backButton.textContent = 'Back to Menu';
        backButton.addEventListener('click', () => {
            clearContent();
            updateStatus("Review completed");
        });
        content.appendChild(backButton);
        return;
    }
    
    const currentWord = words[index];
    clearContent();
    
    const progress = document.createElement('p');
    progress.textContent = `Review progress: ${index}/${dailyGoal}`;
    content.appendChild(progress);
    
    const wordDisplay = document.createElement('h3');
    wordDisplay.textContent = currentWord.word;
    content.appendChild(wordDisplay);
    
    const statusInfo = document.createElement('p');
    statusInfo.textContent = `Current status: ${currentWord.originalStatus}`;
    content.appendChild(statusInfo);
    
    const buttonGroup = document.createElement('div');
    buttonGroup.className = 'button-group';
    
    // Mark as known button
    const knownButton = document.createElement('button');
    knownButton.textContent = 'Mark as Known';
    knownButton.className = 'status-known';
    knownButton.addEventListener('click', () => {
        updateWordReviewStatus(currentWord.word, 'known');
        reviewNextWord(words, index + 1, dailyGoal);
    });
    
    // Keep status button
    const keepButton = document.createElement('button');
    keepButton.textContent = 'Keep Status';
    keepButton.addEventListener('click', () => {
        updateWordReviewStatus(currentWord.word, currentWord.originalStatus);
        reviewNextWord(words, index + 1, dailyGoal);
    });
    
    // Skip button
    const skipButton = document.createElement('button');
    skipButton.textContent = 'Skip';
    skipButton.className = 'cancel';
    skipButton.addEventListener('click', () => {
        reviewNextWord(words, index + 1, dailyGoal);
    });
    
    buttonGroup.appendChild(knownButton);
    buttonGroup.appendChild(keepButton);
    buttonGroup.appendChild(skipButton);
    content.appendChild(buttonGroup);
    
    // Record review time
    const reviewData = {
        lastReviewed: new Date().toISOString(),
        timesReviewed: (() => {
            const existingData = localStorage.getItem(`word_review_${currentWord.word}`);
            return existingData ? JSON.parse(existingData).timesReviewed + 1 : 1;
        })()
    };
    localStorage.setItem(`word_review_${currentWord.word}`, JSON.stringify(reviewData));
}

function updateWordReviewStatus(word, newStatus) {
    if (newStatus !== vocabStats[word]) {
        vocabStats[word] = newStatus;
        saveData();
        
        // Show brief feedback
        const feedback = document.createElement('p');
        feedback.className = 'correct';
        feedback.textContent = `"${word}" marked as ${newStatus}`;
        content.insertBefore(feedback, content.firstChild);
        
        // Remove feedback after 2 seconds
        setTimeout(() => {
            feedback.remove();
        }, 2000);
    }
}

function clearAllData() {
    showConfirm("This will delete ALL data (words, groups, stats, reviews). Are you sure?", (confirmed) => {
        if (confirmed) {
            // Backup data to localStorage before clearing
            const backup = {
                vocabulary: localStorage.getItem(DATA_KEY),
                recycleBin: localStorage.getItem(RECYCLE_BIN_KEY),
                bulletin: localStorage.getItem(BULLETIN_BOARD_KEY),
                stats: localStorage.getItem(VOCAB_STATS_KEY)
            };
            localStorage.setItem('vocab_backup', JSON.stringify(backup));
            
            // Clear all data
            localStorage.removeItem(DATA_KEY);
            localStorage.removeItem(RECYCLE_BIN_KEY);
            localStorage.removeItem(BULLETIN_BOARD_KEY);
            localStorage.removeItem(VOCAB_STATS_KEY);
            
            // Clear review data
            Object.keys(localStorage).forEach(key => {
                if (key.startsWith('word_review_')) {
                    localStorage.removeItem(key);
                }
            });
            
            // Reset in-memory data
            mp.clear();
            cnt = 0;
            for (let i = 0; i < N; i++) {
                fa[i] = i;
                bac[i] = "";
            }
            recycleBin = [];
            bulletinBoard = [];
            vocabStats = {};
            
            clearContent();
            const successMsg = document.createElement('p');
            successMsg.className = 'correct';
            successMsg.textContent = 'All data cleared. Backup saved in localStorage (vocab_backup).';
            content.appendChild(successMsg);
            
            updateStatus("All data cleared");
        }
    });
}

    function showWordList(statusType) {
    clearContent();

    const title = document.createElement('h3');
    title.textContent = `${statusType.charAt(0).toUpperCase() + statusType.slice(1)} Words`;
    content.appendChild(title);

    const filteredWords = Object.entries(vocabStats)
        .filter(([word, status]) => status === statusType)
        .map(([word]) => word);

    if (filteredWords.length === 0) {
        const emptyMsg = document.createElement('p');
        emptyMsg.textContent = `No ${statusType} words found.`;
        content.appendChild(emptyMsg);
    } else {
        const wordList = document.createElement('div');
        wordList.className = 'word-list';

        filteredWords.forEach(word => {
            const wordItem = document.createElement('div');
            wordItem.className = 'vocab-word';

            wordItem.innerHTML = `
                <span>${word}</span>
                <div class="word-status">
                    ${['known', 'unsure', 'unknown']
                        .filter(s => s !== statusType)
                        .map(s => `
                            <button class="status-btn status-${s}" 
                                    onclick="updateWordStatusAndRefresh('${word}', '${s}', '${statusType}')">
                                ${s.charAt(0).toUpperCase() + s.slice(1)}
                            </button>
                        `).join('')}
                    <button class="cancel delete-btn">Delete</button>
                </div>
            `;

            wordItem.querySelector('.delete-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                
                showConfirm(`Remove "${word}" from ${statusType} words?`, (confirmed) => {
                    if (confirmed) {
                        recycleBin.push({
                            word: word,
                            group: ["STATUS_DELETION"],
                            timestamp: new Date().toISOString(),
                            source: `Removed from ${statusType} words`
                        });
                        
                        delete vocabStats[word];
                        saveData();
                        
                        clearContent();
                        const result = document.createElement('div');
                        result.className = 'deletion-result';
                        result.innerHTML = `
                            <p class="correct">‚úì "${word}" removed from ${statusType} words</p>
                            <div class="button-group">
                                <button onclick="showWordList('${statusType}')">
                                    Back to List
                                </button>
                                <button onclick="handleMenuChoice('${currentChoice}')">
                                    Back to Menu
                                </button>
                            </div>
                        `;
                        content.appendChild(result);
                    }
                });
            });

            wordList.appendChild(wordItem);
        });

        content.appendChild(wordList);

        const clearAllBtn = document.createElement('button');
        clearAllBtn.textContent = `üßπ Clear All ${statusType} Words`;
        clearAllBtn.className = 'cancel';
        clearAllBtn.style.marginTop = '20px';
        clearAllBtn.addEventListener('click', () => {
            showConfirm(`Clear ALL ${statusType} words? This cannot be undone!`, (confirmed) => {
                if (confirmed) {
                    const deletedWords = Object.keys(vocabStats)
                        .filter(w => vocabStats[w] === statusType);
                    
                    if (deletedWords.length > 0) {
                        recycleBin.push({
                            word: "BATCH_DELETE",
                            group: deletedWords,
                            timestamp: new Date().toISOString(),
                            source: `Cleared all ${statusType} words`
                        });
                    }
                    
                    deletedWords.forEach(w => delete vocabStats[w]);
                    saveData();
                    
                    clearContent();
                    const result = document.createElement('div');
                    result.className = 'deletion-result';
                    result.innerHTML = `
                        <p class="correct">‚úì Cleared all ${statusType} words</p>
                        <p>Removed ${deletedWords.length} words from vocabulary status.</p>
                        <div class="button-group">
                            <button onclick="handleMenuChoice('${currentChoice}')">
                                Back to Menu
                            </button>
                        </div>
                    `;
                    content.appendChild(result);
                }
            });
        });

        content.appendChild(clearAllBtn);
    }

    const backButton = document.createElement('button');
    backButton.textContent = '‚Üê Back to Main Menu';
    backButton.className = 'cancel';
    backButton.style.marginTop = '20px';
    backButton.addEventListener('click', () => {
        handleMenuChoice(currentChoice);
    });
    content.appendChild(backButton);
}

// New helper function for status changes
function updateWordStatusAndRefresh(word, newStatus, currentStatusType) {
    updateWordStatus(word, newStatus);
    setTimeout(() => {
        showWordList(currentStatusType);
    }, 1000);
}
    
    function restoreFromRecycleBin(index) {
    const item = recycleBin[index];
    
    if (item.word === "ALL_WORDS") {
        // Restore all words (special case for clear all)
        for (const word of item.group) {
            if (!mp.has(word)) {
                mp.set(word, ++cnt);
                bac[cnt] = word;
            }
        }
    } else if (item.group && item.group[0] === "STATUS_DELETION") {
        // Restore vocabulary status with original status
        const statusMatch = item.source.match(/Removed from (known|unknown|unsure) words/);
        if (statusMatch && statusMatch[1]) {
            vocabStats[item.word] = statusMatch[1];
        }
    } else if (item.source.includes("Cleared all")) {
        // Restore vocabulary status from batch delete
        const statusMatch = item.source.match(/Cleared all (known|unknown|unsure) words/);
        if (statusMatch && statusMatch[1]) {
            const status = statusMatch[1];
            for (const word of item.group) {
                vocabStats[word] = status;
            }
        }
    } else {
        // Restore word or word group
        for (const word of item.group) {
            if (!mp.has(word)) {
                mp.set(word, ++cnt);
                bac[cnt] = word;
            }
            
            // Reconnect the words in the group
            if (item.group.length > 1) {
                const rootWord = item.word;
                if (mp.has(rootWord)) {
                    union_set(mp.get(rootWord), mp.get(word));
                }
            }
        }
    }
    
    // Remove from recycle bin
    recycleBin.splice(index, 1);
    
    if (saveData()) {
        showRecycleBin();
        const successMsg = document.createElement('p');
        successMsg.className = 'correct';
        successMsg.textContent = item.word === "ALL_WORDS" ? 
            'All words restored successfully!' : 
            'Item restored successfully!';
        content.insertBefore(successMsg, content.firstChild);
        updateStatus("Restore completed");
    } else {
        const errorMsg = document.createElement('p');
        errorMsg.className = 'incorrect';
        errorMsg.textContent = 'Error during restore';
        content.insertBefore(errorMsg, content.firstChild);
        updateStatus("Restore failed");
    }
}
    
    function showConfirm(message, callback) {
        clearContent();
        
        const confirmDiv = document.createElement('div');
        confirmDiv.className = 'confirm-prompt';
        
        const messageP = document.createElement('p');
        messageP.textContent = message;
        confirmDiv.appendChild(messageP);
        
        const buttonGroup = document.createElement('div');
        buttonGroup.className = 'button-group';
        
        const yesButton = document.createElement('button');
        yesButton.textContent = 'Yes';
        yesButton.addEventListener('click', () => {
            callback(true);
        });
        
        const noButton = document.createElement('button');
        noButton.textContent = 'No';
        noButton.className = 'cancel';
        noButton.addEventListener('click', () => {
            callback(false);
            clearContent();
            updateStatus("Operation canceled");
        });
        
        buttonGroup.appendChild(yesButton);
        buttonGroup.appendChild(noButton);
        confirmDiv.appendChild(buttonGroup);
        
        content.appendChild(confirmDiv);
    }
    
        // Calendar and stats functions
        const CALENDAR_DATA_KEY = "learning_calendar_data";
        let calendarData = {};
        
        function showLearningCalendar() {
    clearContent();
    loadCalendarData();
    
    const today = new Date();
    let currentMonth = today.getMonth();
    let currentYear = today.getFullYear();
    
    // Ê∑ªÂä†Áä∂ÊÄÅÂèòÈáèÊù•Ë∑üË∏™ÂΩìÂâçÊòæÁ§∫ÁöÑÊúà‰ªΩÂíåÂπ¥‰ªΩ
    if (!window.calendarState) {
        window.calendarState = { month: currentMonth, year: currentYear };
    } else {
        currentMonth = window.calendarState.month;
        currentYear = window.calendarState.year;
    }
    
    const container = document.createElement('div');
    container.className = 'calendar-container';
    
    // Header with month/year and navigation
    const header = document.createElement('div');
    header.className = 'calendar-header';
    
    const title = document.createElement('h3');
    title.textContent = `${new Date(currentYear, currentMonth, 1).toLocaleString('default', { month: 'long' })} ${currentYear}`;
    header.appendChild(title);
    
    const nav = document.createElement('div');
    nav.className = 'calendar-nav';
    
    const prevButton = document.createElement('button');
    prevButton.textContent = '‚Üê';
    prevButton.addEventListener('click', () => {
        if (currentMonth === 0) {
            currentMonth = 11;
            currentYear--;
        } else {
            currentMonth--;
        }
        window.calendarState = { month: currentMonth, year: currentYear };
        showLearningCalendar();
    });
    
    const nextButton = document.createElement('button');
    nextButton.textContent = '‚Üí';
    nextButton.addEventListener('click', () => {
        if (currentMonth === 11) {
            currentMonth = 0;
            currentYear++;
        } else {
            currentMonth++;
        }
        window.calendarState = { month: currentMonth, year: currentYear };
        showLearningCalendar();
    });
    
    nav.appendChild(prevButton);
    nav.appendChild(nextButton);
    header.appendChild(nav);
    container.appendChild(header);
    
    // Day names header
    const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    const dayNamesRow = document.createElement('div');
    dayNamesRow.className = 'calendar-grid';
    
    dayNames.forEach(day => {
        const dayElement = document.createElement('div');
        dayElement.textContent = day;
        dayElement.style.fontWeight = 'bold';
        dayNamesRow.appendChild(dayElement);
    });
    
    container.appendChild(dayNamesRow);
    
    // Calendar grid
    const firstDay = new Date(currentYear, currentMonth, 1).getDay();
    const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
    
    const grid = document.createElement('div');
    grid.className = 'calendar-grid';
    
    // Empty cells for days before the first of the month
    for (let i = 0; i < firstDay; i++) {
        const emptyCell = document.createElement('div');
        emptyCell.className = 'calendar-day empty';
        grid.appendChild(emptyCell);
    }
    
    // Days of the month
    for (let day = 1; day <= daysInMonth; day++) {
        const dateStr = `${currentYear}-${String(currentMonth + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
        const dayData = calendarData[dateStr];
        
        const dayElement = document.createElement('div');
        dayElement.className = 'calendar-day';
        
        const dayNumber = document.createElement('div');
        dayNumber.textContent = day;
        dayElement.appendChild(dayNumber);
        
        if (day === today.getDate() && currentMonth === today.getMonth() && currentYear === today.getFullYear()) {
            dayElement.classList.add('today');
        }
        
        if (dayData) {
            dayElement.classList.add('has-data');
            dayElement.classList.add(dayData.efficient ? 'efficient' : 'inefficient');
            
            const dayInfo = document.createElement('div');
            dayInfo.style.fontSize = '0.7em';
            dayInfo.innerHTML = `
                ${dayData.duration}min<br>
                ${dayData.wordCount}voc(s)
            `;
            dayElement.appendChild(dayInfo);
        } else {
            const dayInfo = document.createElement('div');
            dayInfo.style.fontSize = '0.7em';
            dayInfo.innerHTML = `0min<br>0voc(s)`;
            dayElement.appendChild(dayInfo);
        }
        
        dayElement.addEventListener('click', () => {
            showDayDetails(dateStr, dayData);
        });
        
        grid.appendChild(dayElement);
    }
    
    container.appendChild(grid);
    
    // Weekly stats chart
    const statsContainer = document.createElement('div');
    statsContainer.className = 'stats-container';
    
    const statsTitle = document.createElement('h4');
    statsTitle.textContent = 'Last 14 Days Stats';
    statsContainer.appendChild(statsTitle);
    
    const chart = document.createElement('div');
    chart.className = 'stats-chart';
    
    const last14Days = getLast14Days();
    const maxDuration = Math.max(...last14Days.map(day => calendarData[day.date]?.duration || 0), 1);
    
    last14Days.forEach(day => {
        const dayData = calendarData[day.date];
        const hasData = dayData && (dayData.duration > 0 || dayData.wordCount > 0);
        
        // ÊõøÊç¢ÂéüÊúâÁöÑbarÂàõÂª∫‰ª£Á†Å
const bar = document.createElement('div');
bar.className = `chart-bar ${hasData ? (dayData.efficient ? 'efficient' : 'inefficient') : 'inefficient'}`;
bar.style.height = `${hasData ? (dayData.duration / maxDuration) * 150 : 5}px`;

const valueLabel = document.createElement('div');
valueLabel.className = 'chart-value';
valueLabel.textContent = hasData ? dayData.duration : '0';
bar.appendChild(valueLabel);

const dateLabel = document.createElement('div');
dateLabel.className = 'chart-label';
dateLabel.textContent = day.date.split('-').slice(1).join('/');
bar.appendChild(dateLabel);
        
        chart.appendChild(bar);
    });
    
    statsContainer.appendChild(chart);
    container.appendChild(statsContainer);
    
    content.appendChild(container);
    updateStatus("Learning calendar");
}
        
        function showDayDetails(dateStr, existingData = null) {
            clearContent();
            
            const date = new Date(dateStr);
            const container = document.createElement('div');
            container.className = 'input-container';
            
            const title = document.createElement('h3');
            title.textContent = `Learning Log - ${date.toLocaleDateString()}`;
            container.appendChild(title);
            
            const wordCountLabel = document.createElement('label');
            wordCountLabel.textContent = 'Words studied today:';
            container.appendChild(wordCountLabel);
            
            const wordCountInput = document.createElement('input');
            wordCountInput.type = 'number';
            wordCountInput.min = '0';
            wordCountInput.value = existingData?.wordCount || '0';
            container.appendChild(wordCountInput);
            
            const durationLabel = document.createElement('label');
            durationLabel.textContent = 'Study duration (minutes):';
            container.appendChild(durationLabel);
            
            const durationInput = document.createElement('input');
            durationInput.type = 'number';
            durationInput.min = '0';
            durationInput.value = existingData?.duration || '0';
            container.appendChild(durationInput);
            
            const efficientLabel = document.createElement('label');
            efficientLabel.textContent = 'Was this an efficient study session?';
            container.appendChild(efficientLabel);
            
            const efficientCheckbox = document.createElement('input');
            efficientCheckbox.type = 'checkbox';
            efficientCheckbox.checked = existingData?.efficient || false;
            container.appendChild(efficientCheckbox);
            
            const buttonGroup = document.createElement('div');
            buttonGroup.className = 'button-group';
            
            const saveButton = document.createElement('button');
            saveButton.textContent = 'Save';
            saveButton.addEventListener('click', () => {
                const wordCount = parseInt(wordCountInput.value) || 0;
                const duration = parseInt(durationInput.value) || 0;
                const efficient = efficientCheckbox.checked;
                
                if (wordCount > 0 || duration > 0) {
                    calendarData[dateStr] = {
                        wordCount,
                        duration,
                        efficient,
                        timestamp: new Date().toISOString()
                    };
                    saveCalendarData();
                    
                    const details = document.createElement('div');
                    details.className = 'day-details';
                    details.innerHTML = `
                        <p>Words studied: ${wordCount}</p>
                        <p>Study duration: ${duration} minutes</p>
                        <p>Efficiency: ${efficient ? '‚úÖ Efficient' : '‚ùå Not efficient'}</p>
                    `;
                    container.appendChild(details);
                    
                    updateStatus("Day data saved");
                } else {
                    // Remove entry if both are 0
                    if (calendarData[dateStr]) {
                        delete calendarData[dateStr];
                        saveCalendarData();
                    }
                    updateStatus("Day data cleared (no words or duration)");
                }
                
                showLearningCalendar();
            });
            
            const cancelButton = document.createElement('button');
            cancelButton.textContent = 'Back to Calendar';
            cancelButton.className = 'cancel';
            cancelButton.addEventListener('click', () => {
                showLearningCalendar();
            });
            
            buttonGroup.appendChild(saveButton);
            buttonGroup.appendChild(cancelButton);
            container.appendChild(buttonGroup);
            
            if (existingData) {
                const details = document.createElement('div');
                details.className = 'day-details';
                details.innerHTML = `
                    <p>Words studied: ${existingData.wordCount}</p>
                    <p>Study duration: ${existingData.duration} minutes</p>
                    <p>Efficiency: ${existingData.efficient ? '‚úÖ Efficient' : '‚ùå Not efficient'}</p>
                `;
                container.appendChild(details);
            }
            
            content.appendChild(container);
        }
        
        function loadCalendarData() {
            const savedData = localStorage.getItem(CALENDAR_DATA_KEY);
            if (savedData) {
                try {
                    calendarData = JSON.parse(savedData);
                } catch (e) {
                    console.error("Error loading calendar data:", e);
                    calendarData = {};
                }
            } else {
                calendarData = {};
            }
        }
        
        function saveCalendarData() {
            try {
                localStorage.setItem(CALENDAR_DATA_KEY, JSON.stringify(calendarData));
                return true;
            } catch (e) {
                console.error("Error saving calendar data:", e);
                return false;
            }
        }
        
        function getLast14Days() {
    const result = [];
    for (let i = 13; i >= 0; i--) {
        const date = new Date();
        date.setDate(date.getDate() - i);
        const dateStr = date.toISOString().split('T')[0];
        result.push({ date: dateStr });
    }
    return result;
}

    function exitProgram() {
        if (saveData()) {
            clearContent();
            const goodbyeMsg = document.createElement('p');
            goodbyeMsg.className = 'correct';
            goodbyeMsg.textContent = 'Saving data... Goodbye!';
            content.appendChild(goodbyeMsg);
            
            setTimeout(() => {
                clearContent();
                const exitMsg = document.createElement('p');
                exitMsg.textContent = 'Program ended (refresh page in browser to restart)';
                content.appendChild(exitMsg);
            }, 1000);
        }
    }
</script>
</body> 
</html> 